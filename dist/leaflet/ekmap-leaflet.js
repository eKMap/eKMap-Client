/*!
 * 
 *          ekmap-leaflet.(https://ekgis.com.vn/)
 *          Copyright© 2009 - 2020 eKGIS
 *          license: Apache-2.0
 *          version: v0.0.1
 *         
 */
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/leaflet/core/Base.js":
/*!**********************************!*\
  !*** ./src/leaflet/core/Base.js ***!
  \**********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet */ \"leaflet\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);\n/**\r\n * @namespace L\r\n * @category BaseType Namespace\r\n */\n\n/**\r\n * @namespace L.ekmap\r\n * @category BaseType Namespace\r\n */\n\n/**\r\n * @namespace L.ekmap.control\r\n * @category BaseType Namespace\r\n */\n //thay đổi nội dung\n\nleaflet__WEBPACK_IMPORTED_MODULE_0___default.a.ekmap = leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.ekmap || {};\nleaflet__WEBPACK_IMPORTED_MODULE_0___default.a.ekmap.control = leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.ekmap.control || {};\n\n//# sourceURL=webpack:///./src/leaflet/core/Base.js?");

/***/ }),

/***/ "./src/leaflet/core/Parse.js":
/*!***********************************!*\
  !*** ./src/leaflet/core/Parse.js ***!
  \***********************************/
/*! exports provided: Parse */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Parse\", function() { return Parse; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Parse = /*#__PURE__*/function () {\n  function Parse() {\n    _classCallCheck(this, Parse);\n  }\n\n  _createClass(Parse, null, [{\n    key: \"arcgisToGeoJSON\",\n    value: function (_arcgisToGeoJSON) {\n      function arcgisToGeoJSON(_x, _x2) {\n        return _arcgisToGeoJSON.apply(this, arguments);\n      }\n\n      arcgisToGeoJSON.toString = function () {\n        return _arcgisToGeoJSON.toString();\n      };\n\n      return arcgisToGeoJSON;\n    }(function (arcgis, idAttribute) {\n      var geojson = {};\n\n      if (arcgis.features) {\n        geojson.type = 'FeatureCollection';\n        geojson.features = [];\n\n        for (var i = 0; i < arcgis.features.length; i++) {\n          geojson.features.push(arcgisToGeoJSON(arcgis.features[i], idAttribute));\n        }\n      }\n\n      if (typeof arcgis.x === 'number' && typeof arcgis.y === 'number') {\n        geojson.type = 'Point';\n        geojson.coordinates = [arcgis.x, arcgis.y];\n\n        if (typeof arcgis.z === 'number') {\n          geojson.coordinates.push(arcgis.z);\n        }\n      }\n\n      if (arcgis.points) {\n        geojson.type = 'MultiPoint';\n        geojson.coordinates = arcgis.points.slice(0);\n      }\n\n      if (arcgis.paths) {\n        if (arcgis.paths.length === 1) {\n          geojson.type = 'LineString';\n          geojson.coordinates = arcgis.paths[0].slice(0);\n        } else {\n          geojson.type = 'MultiLineString';\n          geojson.coordinates = arcgis.paths.slice(0);\n        }\n      }\n\n      if (arcgis.rings) {\n        geojson = convertRingsToGeoJSON(arcgis.rings.slice(0));\n      }\n\n      if (typeof arcgis.xmin === 'number' && typeof arcgis.ymin === 'number' && typeof arcgis.xmax === 'number' && typeof arcgis.ymax === 'number') {\n        geojson.type = 'Polygon';\n        geojson.coordinates = [[[arcgis.xmax, arcgis.ymax], [arcgis.xmin, arcgis.ymax], [arcgis.xmin, arcgis.ymin], [arcgis.xmax, arcgis.ymin], [arcgis.xmax, arcgis.ymax]]];\n      }\n\n      if (arcgis.geometry || arcgis.attributes) {\n        geojson.type = 'Feature';\n        geojson.geometry = arcgis.geometry ? arcgisToGeoJSON(arcgis.geometry) : null;\n        geojson.properties = arcgis.attributes ? shallowClone(arcgis.attributes) : null;\n\n        if (arcgis.attributes) {\n          try {\n            geojson.id = getId(arcgis.attributes, idAttribute);\n          } catch (err) {// don't set an id\n          }\n        }\n      } // if no valid geometry was encountered\n\n\n      if (JSON.stringify(geojson.geometry) === JSON.stringify({})) {\n        geojson.geometry = null;\n      }\n\n      if (arcgis.spatialReference && arcgis.spatialReference.wkid && arcgis.spatialReference.wkid !== 4326) {\n        console.warn('Object converted in non-standard crs - ' + JSON.stringify(arcgis.spatialReference));\n      }\n\n      return geojson;\n    })\n  }, {\n    key: \"geojsonToArcGIS\",\n    value: function (_geojsonToArcGIS) {\n      function geojsonToArcGIS(_x3, _x4) {\n        return _geojsonToArcGIS.apply(this, arguments);\n      }\n\n      geojsonToArcGIS.toString = function () {\n        return _geojsonToArcGIS.toString();\n      };\n\n      return geojsonToArcGIS;\n    }(function (geojson, idAttribute) {\n      idAttribute = idAttribute || 'OBJECTID';\n      var spatialReference = {\n        wkid: 4326\n      };\n      var result = {};\n      var i;\n      var geojson = geojson;\n\n      switch (geojson.type) {\n        case 'Point':\n          result.x = geojson.coordinates[0];\n          result.y = geojson.coordinates[1];\n          result.spatialReference = spatialReference;\n          break;\n\n        case 'MultiPoint':\n          result.points = geojson.coordinates.slice(0);\n          result.spatialReference = spatialReference;\n          break;\n\n        case 'LineString':\n          result.paths = [geojson.coordinates.slice(0)];\n          result.spatialReference = spatialReference;\n          break;\n\n        case 'MultiLineString':\n          result.paths = geojson.coordinates.slice(0);\n          result.spatialReference = spatialReference;\n          break;\n\n        case 'Polygon':\n          result.rings = geojson.coordinates;\n          result.spatialReference = spatialReference;\n          break;\n\n        case 'MultiPolygon':\n          result.rings = flattenMultiPolygonRings(geojson.coordinates.slice(0));\n          result.spatialReference = spatialReference;\n          break;\n\n        case 'Feature':\n          if (geojson.geometry && geojson.geometry.type != 'Polyline') {\n            result.geometry = this.geojsonToArcGIS(geojson.geometry, idAttribute);\n          }\n\n          if (geojson.properties) result.attributes = geojson.properties ? this.shallowClone(geojson.properties) : {}; //if (geojson.id)\n          //    result.attributes[idAttribute] = geojson.id;\n\n          break;\n\n        case 'FeatureCollection':\n          result = [];\n\n          for (i = 0; i < geojson.features.length; i++) {\n            result.push(this.geojsonToArcGIS(geojson.features[i], idAttribute));\n          }\n\n          break;\n\n        case 'GeometryCollection':\n          result = [];\n\n          for (i = 0; i < geojson.geometries.length; i++) {\n            result.push(geojsonToArcGIS(geojson.geometries[i], idAttribute));\n          }\n\n          break;\n      }\n\n      return result;\n    })\n  }, {\n    key: \"shallowClone\",\n    value: function shallowClone(obj) {\n      var target = {};\n\n      for (var i in obj) {\n        if (obj.hasOwnProperty(i)) {\n          target[i] = obj[i];\n        }\n      }\n\n      return target;\n    }\n  }]);\n\n  return Parse;\n}();\nL.ekmap.Parse = Parse;\n\n//# sourceURL=webpack:///./src/leaflet/core/Parse.js?");

/***/ }),

/***/ "./src/leaflet/core/Request.js":
/*!*************************************!*\
  !*** ./src/leaflet/core/Request.js ***!
  \*************************************/
/*! exports provided: Request */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Request\", function() { return Request; });\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet */ \"leaflet\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Base */ \"./src/leaflet/core/Base.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar Request = /*#__PURE__*/function () {\n  function Request() {\n    _classCallCheck(this, Request);\n  }\n\n  _createClass(Request, [{\n    key: \"get\",\n\n    /** Phương thức GET\r\n     * @param {*} options\r\n     *  @param {string} options.url\r\n     *  @param {string} options.auth Xác thực nếu cần, dạng btoa(\"username:password\");\r\n     *  @param {string} options.dataType Loại dữ liệu trả về, mặc định JSON\r\n     *  @param {string} options.success Hàm callback khi success\r\n     *  @param {string} options.error Hàm callback khi error\r\n     */\n    value: function get(options) {\n      var ajax = new gclient_ajax(options);\n      if (options.success) ajax.on('success', function (e) {\n        options.success(e.response, e);\n      });\n      if (options.error) ajax.on('error', function (e) {\n        options.error(e);\n      });\n      ajax.send(options.url, options.data, options.options);\n    }\n  }, {\n    key: \"put\",\n\n    /** Phương thức PUT\r\n     * @param {*} options\r\n     *  @param {string} options.url\r\n     *  @param {string} options.auth Xác thực nếu cần, dạng btoa(\"username:password\");\r\n     *  @param {string} options.dataType Loại dữ liệu trả về, mặc định JSON\r\n     *  @param {string} options.data Dữ liệu PUT lên\r\n     *  @param {string} options.success Hàm callback khi success\r\n     *  @param {string} options.error Hàm callback khi error\r\n     */\n    value: function put(options) {\n      var ajax = new gclient_ajax(options);\n      if (options.success) ajax.on('success', function (e) {\n        options.success(e.response, e);\n      });\n      if (options.error) ajax.on('error', function (e) {\n        options.error(e);\n      });\n      ajax.send(options.url, options.data, options.options, \"PUT\");\n    }\n  }], [{\n    key: \"send\",\n    value: function send(url, data, options, callback) {\n      options = options || {};\n      var self = this; // Url\n\n      var encode = options.encode !== false;\n      if (encode) url = encodeURI(url); // New request\n\n      var ajax = new XMLHttpRequest();\n      ajax.open(\"GET\", url, true);\n\n      if (options.header) {\n        for (var header in options.header) {\n          ajax.setRequestHeader(header, options.header[header]);\n        }\n      } // Load complete\n      //this.dispatchEvent({ type: 'loadstart' });\n\n\n      ajax.onload = function () {\n        // self._request = null;\n        // self.dispatchEvent({ type: 'loadend' });\n        if (this.status >= 200 && this.status < 400) {\n          var response;\n          var error; // Decode response\n\n          try {\n            response = JSON.parse(this.response); // if (response.features) {\n            //     callback(response.features);\n            // }\n            // if (response.results) {\n            //     callback(response.results);\n            // }\n            // if (response.layers) {\n            //     callback(response);\n            // }\n            // if (response.objectIdFieldName && !response.features) {\n            //     callback(response)\n            // }\n            // if (response.osm_type) {\n            //     callback(response)\n            // }\n            // if (response.length > 0 && response[0].osm_type) {\n            //     callback(response)\n            // }\n          } catch (e) {\n            response = null;\n            error = {\n              message: 'An error occurred.'\n            };\n          }\n\n          if (!error && response.error) {\n            error = response.error;\n            response = null;\n          }\n\n          callback(error, response);\n        } else {}\n      }; // Oops\n\n\n      ajax.onerror = function () {}; // GO!\n\n\n      if (data) ajax.send(JSON.stringify(data));else ajax.send();\n    }\n  }, {\n    key: \"post\",\n\n    /** Phương thức POST\r\n     * @param {*} options\r\n     *  @param {string} options.url\r\n     *  @param {string} options.auth Xác thực nếu cần, dạng btoa(\"username:password\");\r\n     *  @param {string} options.dataType Loại dữ liệu trả về, mặc định JSON\r\n     *  @param {string} options.data Dữ liệu POST lên\r\n     *  @param {string} options.success Hàm callback khi success\r\n     *  @param {string} options.error Hàm callback khi error\r\n     */\n    value: function post(url, data, options, callback) {\n      options = options || {};\n      var encode = options.encode !== false;\n      if (encode) url = encodeURI(url);\n\n      if (data.adds || data.updates || data.deletes) {\n        var dataPost = new FormData();\n        dataPost.append(\"f\", \"json\");\n        dataPost.append(\"adds\", data.adds);\n        dataPost.append(\"updates\", data.updates);\n        dataPost.append(\"deletes\", data.deletes);\n        if (options.token) dataPost.append(\"token\", options.token);\n      } else {\n        if (isNaN(data % 2)) {\n          var dataPost = new FormData();\n          dataPost.append(\"f\", \"json\");\n          dataPost.append(\"features\", data);\n          if (options.token) dataPost.append(\"token\", options.token);\n        } else {\n          var dataPost = new FormData();\n          dataPost.append(\"f\", \"json\");\n          dataPost.append(\"objectIds\", data);\n          if (options.token) dataPost.append(\"token\", options.token);\n        }\n      }\n\n      var ajax = new XMLHttpRequest();\n      ajax.open(\"POST\", url, false);\n\n      if (options.header) {\n        for (var header in options.header) {\n          ajax.setRequestHeader(\"Content-Type\", options.header[header]);\n        }\n      } // Load complete\n\n\n      ajax.onload = function () {\n        // self._request = null;\n        // self.dispatchEvent({ type: 'loadend' });\n        if (this.status >= 200 && this.status < 400) {\n          var response;\n          var error; // Decode response\n\n          try {\n            response = JSON.parse(this.response);\n          } catch (e) {\n            response = null;\n            error = {\n              message: 'An error occurred.'\n            };\n          }\n\n          if (!error && response.error) {\n            error = response.error;\n            response = null;\n          }\n\n          callback(error, response);\n        } else {}\n      }; // Oops\n\n\n      ajax.onerror = function () {}; // GO!\n\n\n      if (dataPost) {\n        ajax.send(dataPost);\n      } else ajax.post();\n    }\n  }]);\n\n  return Request;\n}();\nleaflet__WEBPACK_IMPORTED_MODULE_0___default.a.ekmap.Request = Request;\n\n//# sourceURL=webpack:///./src/leaflet/core/Request.js?");

/***/ }),

/***/ "./src/leaflet/core/Util.js":
/*!**********************************!*\
  !*** ./src/leaflet/core/Util.js ***!
  \**********************************/
/*! exports provided: Util */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Util\", function() { return Util; });\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet */ \"leaflet\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Base */ \"./src/leaflet/core/Base.js\");\n/* harmony import */ var _core_Parse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Parse */ \"./src/leaflet/core/Parse.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n/**\r\n * @class mapboxgl.ekmap.Util\r\n * @category BaseType Util\r\n * @classdesc The tool class.\r\n */\n\nvar Util = /*#__PURE__*/function () {\n  function Util() {\n    _classCallCheck(this, Util);\n  }\n\n  _createClass(Util, null, [{\n    key: \"isNumber\",\n    value: function isNumber(value) {\n      if (value === \"\") {\n        return false;\n      }\n\n      var mdata = Number(value);\n\n      if (mdata === 0) {\n        return true;\n      }\n\n      return !isNaN(mdata);\n    }\n  }, {\n    key: \"isString\",\n    value: function isString(str) {\n      return typeof str === 'string' && str.constructor === String;\n    }\n  }, {\n    key: \"newGuid\",\n    value: function newGuid(attr) {\n      var len = attr || 32;\n      var guid = \"\";\n\n      for (var i = 1; i < len; i++) {\n        var n = Math.floor(Math.random() * 16.0).toString(16);\n        guid += n;\n      }\n\n      return guid;\n    }\n  }, {\n    key: \"hexToRgba\",\n    value: function hexToRgba(hex, opacity) {\n      var color = [],\n          rgba = [];\n      hex = hex.replace(/#/, \"\");\n\n      if (hex.length == 3) {\n        var tmp = [];\n\n        for (var i = 0; i < 3; i++) {\n          tmp.push(hex.charAt(i) + hex.charAt(i));\n        }\n\n        hex = tmp.join(\"\");\n      }\n\n      for (var _i = 0; _i < 6; _i += 2) {\n        color[_i] = \"0x\" + hex.substr(_i, 2);\n        rgba.push(parseInt(Number(color[_i])));\n      }\n\n      rgba.push(opacity);\n      return \"rgba(\" + rgba.join(\",\") + \")\";\n    }\n  }, {\n    key: \"bind\",\n    value: function bind(fn, obj) {\n      var slice = Array.prototype.slice;\n\n      if (fn.bind) {\n        return fn.bind.apply(fn, slice.call(arguments, 1));\n      }\n\n      var args = slice.call(arguments, 2);\n      return function () {\n        return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);\n      };\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize(params) {\n      var data = '';\n      var i = 0;\n      params.f = params.f || 'json';\n\n      for (var key in params) {\n        i++;\n\n        if (params.hasOwnProperty(key)) {\n          var param = params[key];\n          var type = Object.prototype.toString.call(param);\n          var value;\n\n          if (data.length) {\n            data += '&';\n          }\n\n          if (type === '[object Array]') {\n            value = Object.prototype.toString.call(param[0]) === '[object Object]' ? JSON.stringify(param) : param.join(',');\n          } else if (type === '[object Object]') {\n            value = JSON.stringify(param);\n          } else if (type === '[object Date]') {\n            value = param.valueOf();\n          } else {\n            var param = param + '';\n            if (param.indexOf(':') && key != 'layerDefs') param = param.replace(\":\", \"%3A\");\n            if (param.indexOf('/')) param = param.replace(\"/\", \"%2F\");\n            value = param;\n          }\n\n          data += encodeURIComponent(key) + '=' + value;\n        }\n      }\n\n      return data;\n    }\n  }, {\n    key: \"_setGeometry\",\n    value: function _setGeometry(geometry) {\n      var params = {\n        geometry: null,\n        geometryType: null\n      };\n\n      if (geometry instanceof mapboxgl.LngLat) {\n        geometry = {\n          type: 'Point',\n          coordinates: [geometry.lng, geometry.lat]\n        };\n      }\n\n      if (geometry instanceof mapboxgl.LngLatBounds) {\n        // set geometry + geometryType\n        params.geometry = this.boundsToExtent(geometry);\n        params.geometryType = 'esriGeometryEnvelope';\n        return params;\n      } // confirm that our GeoJSON is a point, line or polygon\n\n\n      if (geometry.type === 'Point' || geometry.type === 'LineString' || geometry.type === 'Polygon' || geometry.type === 'MultiPolygon') {\n        params.geometry = _core_Parse__WEBPACK_IMPORTED_MODULE_2__[\"Parse\"].geojsonToArcGIS(geometry);\n        params.geometryType = this.geojsonTypeToArcGIS(geometry.type);\n        return params;\n      } // convert L.Marker > L.LatLng\n\n\n      if (geometry.getLatLng) {\n        geometry = geometry.getLatLng();\n      } // handle L.GeoJSON, pull out the first geometry\n      //if (geometry instanceof GeoJSON) {\n      //    // reassign geometry to the GeoJSON value  (we are assuming that only one feature is present)\n      //    geometry = geometry.getLayers()[0].feature.geometry;\n      //    params.geometry = geojsonToArcGIS(geometry);\n      //    params.geometryType = geojsonTypeToArcGIS(geometry.type);\n      //}\n      // Handle L.Polyline and L.Polygon\n      //if (geometry.toGeoJSON) {\n      //    geometry = geometry.toGeoJSON();\n      //}\n      // handle GeoJSON feature by pulling out the geometry\n\n\n      if (geometry.type === 'Feature') {\n        // get the geometry of the geojson feature\n        geometry = geometry.geometry;\n      }\n    }\n  }, {\n    key: \"boundsToExtent\",\n    value: function boundsToExtent(bounds) {\n      return {\n        'xmin': bounds.getSouthWest().lng,\n        'ymin': bounds.getSouthWest().lat,\n        'xmax': bounds.getNorthEast().lng,\n        'ymax': bounds.getNorthEast().lat,\n        'spatialReference': {\n          'wkid': 4326\n        }\n      };\n    }\n  }, {\n    key: \"geojsonTypeToArcGIS\",\n    value: function geojsonTypeToArcGIS(geoJsonType) {\n      var arcgisGeometryType;\n\n      switch (geoJsonType) {\n        case 'Point':\n          arcgisGeometryType = 'esriGeometryPoint';\n          break;\n\n        case 'MultiPoint':\n          arcgisGeometryType = 'esriGeometryMultipoint';\n          break;\n\n        case 'LineString':\n          arcgisGeometryType = 'esriGeometryPolyline';\n          break;\n\n        case 'MultiLineString':\n          arcgisGeometryType = 'esriGeometryPolyline';\n          break;\n\n        case 'Polygon':\n          arcgisGeometryType = 'esriGeometryPolygon';\n          break;\n\n        case 'MultiPolygon':\n          arcgisGeometryType = 'esriGeometryPolygon';\n          break;\n      }\n\n      return arcgisGeometryType;\n    }\n  }, {\n    key: \"isArray\",\n    value: function isArray(obj) {\n      return Object.prototype.toString.call(obj) === '[object Array]';\n    }\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(obj, options) {\n      if (!Object.prototype.hasOwnProperty.call(obj, 'options')) {\n        obj.options = obj.options ? create(obj.options) : {};\n      }\n\n      for (var i in options) {\n        obj.options[i] = options[i];\n      }\n\n      return obj.options;\n    }\n  }, {\n    key: \"getUrlParams\",\n    value: function getUrlParams(options) {\n      if (options.url) {\n        if (options.url.indexOf('?') !== -1) {\n          options.requestParams = options.requestParams || {};\n          var queryString = options.url.substring(options.url.indexOf('?') + 1);\n          options.url = options.url.split('?')[0];\n          options.requestParams = JSON.parse('{\"' + decodeURI(queryString).replace(/\"/g, '\\\\\"').replace(/&/g, '\",\"').replace(/=/g, '\":\"') + '\"}');\n        }\n\n        options.url = this.cleanUrl(options.url.split('?')[0]);\n      }\n\n      return options;\n    }\n  }, {\n    key: \"getUrl\",\n    value: function getUrl(options) {\n      if (options.url.indexOf('/0') != '-1') option.url = options.url.split('/0').join('');\n      if (options.url.indexOf('/1') != '-1') option.url = options.url.split('/1').join('');\n      if (options.url.indexOf('/2') != '-1') option.url = options.url.split('/2').join('');\n      if (options.url.indexOf('/3') != '-1') option.url = options.url.split('/3').join('');\n      return options;\n    }\n  }, {\n    key: \"getUrlsParams\",\n    value: function getUrlsParams(options) {\n      var string = options.urls.split(\".\")[0];\n      var indexCut = string.indexOf(\"{\") - 1;\n      var stringCut = string.split(string[indexCut])[2];\n      var urls = [];\n\n      for (var i = stringCut[1]; i <= stringCut[3]; i++) {\n        urls.push(options.urls.split(stringCut).join(i));\n      }\n\n      options.urls = urls;\n      return options;\n    }\n  }, {\n    key: \"cleanUrl\",\n    value: function cleanUrl(url) {\n      // trim leading and trailing spaces, but not spaces inside the url\n      // add a trailing slash to the url if the user omitted it\n      if (url[url.length - 1] !== '/') {\n        url += '/';\n      }\n\n      return url;\n    }\n  }, {\n    key: \"splitWords\",\n    value: function splitWords(str) {\n      return this.trim(str).split(/\\s+/);\n    }\n  }, {\n    key: \"trim\",\n    value: function trim(str) {\n      return str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\n    } // @function stamp(obj: Object): Number\n    // Returns the unique ID of an object, assigning it one if it doesn't have it.\n\n  }, {\n    key: \"stamp\",\n    value: function stamp(obj) {\n      /*eslint-disable */\n      var lastId = 0;\n      obj._leaflet_id = obj._leaflet_id || ++lastId;\n      return obj._leaflet_id;\n      /* eslint-enable */\n    }\n  }, {\n    key: \"bind\",\n    value: function bind(fn, obj) {\n      var slice = Array.prototype.slice;\n\n      if (fn.bind) {\n        return fn.bind.apply(fn, slice.call(arguments, 1));\n      }\n\n      var args = slice.call(arguments, 2);\n      return function () {\n        return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);\n      };\n    }\n  }, {\n    key: \"cancelAnimFrame\",\n    value: function cancelAnimFrame(id) {\n      var cancelFn = window.cancelAnimationFrame || this.getPrefixed('CancelAnimationFrame') || this.getPrefixed('CancelRequestAnimationFrame') || function (id) {\n        window.clearTimeout(id);\n      };\n\n      if (id) {\n        cancelFn.call(window, id);\n      }\n    }\n  }, {\n    key: \"getPrefixed\",\n    value: function getPrefixed(name) {\n      return window['webkit' + name] || window['moz' + name] || window['ms' + name];\n    }\n  }, {\n    key: \"formatNum\",\n    value: function formatNum(num, digits) {\n      var pow = Math.pow(10, digits === undefined ? 6 : digits);\n      return Math.round(num * pow) / pow;\n    }\n  }, {\n    key: \"extend\",\n    value: function extend(dest) {\n      var i, j, len, src;\n\n      for (j = 1, len = arguments.length; j < len; j++) {\n        src = arguments[j];\n\n        for (i in src) {\n          dest[i] = src[i];\n        }\n      }\n\n      return dest;\n    }\n  }, {\n    key: \"deepClone\",\n    value: function deepClone(obj) {\n      var _this = this;\n\n      var cloned = {};\n      if (_typeof(obj) !== 'object') return obj;\n      if (obj instanceof Array) return obj.map(function (ele) {\n        return _this.deepClone(ele);\n      });\n\n      for (var k in obj) {\n        if (obj.hasOwnProperty(k) && _typeof(obj[k]) !== 'object') {\n          cloned[k] = obj[k];\n        } else if (obj[k].constructor.toString().indexOf(\"Object\") > 0) {\n          cloned[k] = this.deepClone(obj[k]);\n        } else if (Array.isArray(obj[k])) {\n          cloned[k] = obj[k].map(function (ele) {\n            // let ret = null;\n            if (_typeof(ele) !== 'object') return ele;else return _this.deepClone(ele);\n          }); // cloned[k] = [].concat(obj[k]);\n        }\n      }\n\n      return cloned;\n    }\n    /**\r\n     * @private\r\n     * @description add img, video element to domContainer.\r\n     * @param {Array} dom dom container..\r\n     * @param {Array} res urls of img/video loaded to dom.\r\n     */\n\n  }, {\n    key: \"setResource\",\n    value: function setResource(dom, res) {\n      if (!(res instanceof Array)) return;\n      dom.innerHTML = '';\n\n      for (var i = 0; i < res.length; i++) {\n        var filetype = this.getFiletype(res[i]);\n\n        if (filetype !== \"\") {\n          var _ele = document.createElement(filetype);\n\n          _ele.style.width = _ele.style.height = dom.style.width = dom.style.height = '60px';\n          _ele.style.borderRadius = \"50%\";\n          _ele.src = res[i];\n          dom.style.borderRadius = \"50%\";\n          dom.appendChild(_ele);\n        }\n\n        if (filetype == 'video') {\n          ele.setAttribute('autoplay', true);\n        }\n      }\n    }\n    /**\r\n     * return iconposition style by iconName\r\n     */\n\n  }, {\n    key: \"setIconDiv\",\n    value: function setIconDiv(dom, iconName) {\n      var icons = Const.Sprites;\n\n      if (iconName && icons[iconName]) {\n        var iconStyle = icons[iconName],\n            iconDiv = document.createElement(\"div\");\n        iconDiv.style.width = iconStyle.width + \"px\";\n        iconDiv.style.height = iconStyle.height + \"px\";\n        iconDiv.style.overflow = 'hidden';\n        var iconImg = document.createElement(\"img\");\n        iconImg.src = Const.SpritesUrl + \".png\";\n        iconImg.style.marginLeft = \"-\" + iconStyle.x + \"px\";\n        iconImg.style.marginTop = \"-\" + iconStyle.y + \"px\";\n        iconDiv.appendChild(iconImg);\n        dom.appendChild(iconDiv);\n      }\n    }\n  }, {\n    key: \"isChanged\",\n    value: function isChanged(lastData, data) {\n      if (JSON.stringify(lastData) == JSON.stringify(data)) return false;else {\n        return true;\n      }\n    }\n  }, {\n    key: \"setChart\",\n    value: function setChart(dom, data, type, height, backgroundColor) {\n      if (!Chart) {\n        return;\n      }\n\n      var canv = document.createElement('canvas'),\n          ctx = canv.getContext('2d');\n      if (type == 'bar') canv.style.backgroundColor = backgroundColor ? backgroundColor : 'rgb(245, 222, 179)';else canv.style.backgroundColor = 'rgba(0,0,0,0.0)';\n      var chart = new Chart(ctx, {\n        type: type,\n        data: data,\n        options: {\n          legend: {\n            display: false\n          } // plugins: {\n          //     labels: {\n          //         render: function (args) {\n          //             return args.value;\n          //         },\n          //         fontSize: 10,\n          //         fontStyle: 'normal',\n          //         fontColor: '#fff',\n          //         fontFamily: '\"Lucida Console\", Monaco, monospace'\n          //     }\n          // }\n\n        }\n      });\n      canv.height = height;\n      canv.style.height = canv.height + 'px';\n      canv.width = height;\n      canv.style.width = canv.width + 'px';\n      dom.appendChild(canv);\n      return chart;\n    }\n  }, {\n    key: \"getParamString\",\n    value: function getParamString(obj, existingUrl, uppercase) {\n      var params = [];\n\n      for (var i in obj) {\n        params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));\n      }\n\n      return (!existingUrl || existingUrl.indexOf('?') === -1 ? '?' : '&') + params.join('&');\n    }\n  }, {\n    key: \"getSourceId\",\n    value: function getSourceId(map) {\n      var layers = map.getStyle().layers;\n      var idCheck = layers[0].id % 2;\n\n      if (!isNaN(idCheck)) {\n        var lay = map.getLayer(layers[0].id);\n        return lay.source;\n      }\n    }\n  }]);\n\n  return Util;\n}();\nleaflet__WEBPACK_IMPORTED_MODULE_0___default.a.ekmap.Util = Util;\n\n//# sourceURL=webpack:///./src/leaflet/core/Util.js?");

/***/ }),

/***/ "./src/leaflet/core/index.js":
/*!***********************************!*\
  !*** ./src/leaflet/core/index.js ***!
  \***********************************/
/*! exports provided: Util, Parse, Request */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Util */ \"./src/leaflet/core/Util.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Util\", function() { return _Util__WEBPACK_IMPORTED_MODULE_0__[\"Util\"]; });\n\n/* harmony import */ var _Parse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Parse */ \"./src/leaflet/core/Parse.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Parse\", function() { return _Parse__WEBPACK_IMPORTED_MODULE_1__[\"Parse\"]; });\n\n/* harmony import */ var _Request__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Request */ \"./src/leaflet/core/Request.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Request\", function() { return _Request__WEBPACK_IMPORTED_MODULE_2__[\"Request\"]; });\n\n\n\n\n\n//# sourceURL=webpack:///./src/leaflet/core/index.js?");

/***/ }),

/***/ "./src/leaflet/css/index.js":
/*!**********************************!*\
  !*** ./src/leaflet/css/index.js ***!
  \**********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./style */ \"./src/leaflet/css/style.css\");\n/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style__WEBPACK_IMPORTED_MODULE_0__);\n\n\n//# sourceURL=webpack:///./src/leaflet/css/index.js?");

/***/ }),

/***/ "./src/leaflet/css/style.css":
/*!***********************************!*\
  !*** ./src/leaflet/css/style.css ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin\n\n//# sourceURL=webpack:///./src/leaflet/css/style.css?");

/***/ }),

/***/ "./src/leaflet/index.js":
/*!******************************!*\
  !*** ./src/leaflet/index.js ***!
  \******************************/
/*! exports provided: TiledMapLayer, TiledOSMapLayer, BasemapArcgisLayer, MapService, ServiceBase, FeatureService, IdentifyFeatures, Request */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _layer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./layer */ \"./src/leaflet/layer/index.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TiledMapLayer\", function() { return _layer__WEBPACK_IMPORTED_MODULE_0__[\"TiledMapLayer\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TiledOSMapLayer\", function() { return _layer__WEBPACK_IMPORTED_MODULE_0__[\"TiledOSMapLayer\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"BasemapArcgisLayer\", function() { return _layer__WEBPACK_IMPORTED_MODULE_0__[\"BasemapArcgisLayer\"]; });\n\n/* harmony import */ var _services__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./services */ \"./src/leaflet/services/index.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MapService\", function() { return _services__WEBPACK_IMPORTED_MODULE_1__[\"MapService\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ServiceBase\", function() { return _services__WEBPACK_IMPORTED_MODULE_1__[\"ServiceBase\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"FeatureService\", function() { return _services__WEBPACK_IMPORTED_MODULE_1__[\"FeatureService\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"IdentifyFeatures\", function() { return _services__WEBPACK_IMPORTED_MODULE_1__[\"IdentifyFeatures\"]; });\n\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core */ \"./src/leaflet/core/index.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Request\", function() { return _core__WEBPACK_IMPORTED_MODULE_2__[\"Request\"]; });\n\n\n\n\n\n\n // export * from './control';\n// export * from './core';\n// export * from './layer';\n// export * from './services';\n\n//# sourceURL=webpack:///./src/leaflet/index.js?");

/***/ }),

/***/ "./src/leaflet/layer/BasemapArcgisLayer.js":
/*!*************************************************!*\
  !*** ./src/leaflet/layer/BasemapArcgisLayer.js ***!
  \*************************************************/
/*! exports provided: BasemapArcgisLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BasemapArcgisLayer\", function() { return BasemapArcgisLayer; });\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet */ \"leaflet\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n/**\r\n * @class L.ekmap.BasemapArcgisLayer\r\n * @classdesc The BasemapArcgisLayer class use some arcgis layer and url of them from {@link https://github.com/Esri/esri-leaflet/blob/master/src/Layers/BasemapLayer.js|source}.\r\n * @category  Layer\r\n * @param {string} basemapType basemapType refers to the specific basemap you'd like to add. <br>Use one of \"Streets\", \"Topographic\", \"Oceans\", \"OceansLabels\", \"NationalGeographic\", \"Physical\", \"Gray\", \"GrayLabels\", \"DarkGray\", \"DarkGrayLabels\", \"Imagery\", \"ImageryLabels\", \"ImageryTransportation\", \"ImageryClarity\", \"ImageryFirefly\", ShadedRelief\", \"ShadedReliefLabels\", \"Terrain\", \"TerrainLabels\" or \"USATopo\".\r\n * @extends {L.TileLayer}\r\n * @example\r\n * var map = new L.Map({\r\n *     container: 'map1',\r\n *     center: [103.9, 22.2],\r\n *     zoom: 6\r\n * });\r\n * var baseMap = new L.ekmap.BasemapArcgisLayer('Topographic')\r\n *   .addTo(map);\r\n */\n\nvar tileProtocol = window.location.protocol !== 'https:' ? 'http:' : 'https:';\nvar BasemapArcgisLayer = /*#__PURE__*/function (_TileLayer) {\n  _inherits(BasemapArcgisLayer, _TileLayer);\n\n  var _super = _createSuper(BasemapArcgisLayer);\n\n  function BasemapArcgisLayer(basemapType, options) {\n    var _this;\n\n    _classCallCheck(this, BasemapArcgisLayer);\n\n    _this = _super.call(this);\n    _this.options = options ? options : {};\n    var config;\n    var tiles = {\n      Streets: {\n        urlTemplate: tileProtocol + '//server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}',\n        options: {\n          attribution: 'USGS, NOAA',\n          attributionUrl: 'https://static.arcgis.com/attribution/World_Street_Map'\n        }\n      },\n      Topographic: {\n        urlTemplate: tileProtocol + '//server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}',\n        options: {\n          attribution: 'USGS, NOAA',\n          attributionUrl: 'https://static.arcgis.com/attribution/World_Topo_Map'\n        }\n      },\n      Oceans: {\n        urlTemplate: tileProtocol + '//server.arcgisonline.com/arcgis/rest/services/Ocean/World_Ocean_Base/MapServer/tile/{z}/{y}/{x}',\n        options: {\n          attribution: 'USGS, NOAA',\n          attributionUrl: 'https://static.arcgis.com/attribution/Ocean_Basemap'\n        }\n      },\n      OceansLabels: {\n        urlTemplate: tileProtocol + '//server.arcgisonline.com/arcgis/rest/services/Ocean/World_Ocean_Reference/MapServer/tile/{z}/{y}/{x}',\n        options: {\n          attribution: ''\n        }\n      },\n      NationalGeographic: {\n        urlTemplate: tileProtocol + '//server.arcgisonline.com/ArcGIS/rest/services/NatGeo_World_Map/MapServer/tile/{z}/{y}/{x}',\n        options: {\n          attribution: 'National Geographic, DeLorme, HERE, UNEP-WCMC, USGS, NASA, ESA, METI, NRCAN, GEBCO, NOAA, increment P Corp.'\n        }\n      },\n      DarkGray: {\n        urlTemplate: tileProtocol + '//server.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Dark_Gray_Base/MapServer/tile/{z}/{y}/{x}',\n        options: {\n          attribution: 'HERE, DeLorme, MapmyIndia, &copy; OpenStreetMap contributors'\n        }\n      },\n      DarkGrayLabels: {\n        urlTemplate: tileProtocol + '//server.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Dark_Gray_Reference/MapServer/tile/{z}/{y}/{x}',\n        options: {\n          attribution: ''\n        }\n      },\n      Gray: {\n        urlTemplate: tileProtocol + '//server.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Base/MapServer/tile/{z}/{y}/{x}',\n        options: {\n          attribution: 'HERE, DeLorme, MapmyIndia, &copy; OpenStreetMap contributors'\n        }\n      },\n      GrayLabels: {\n        urlTemplate: tileProtocol + '//server.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Reference/MapServer/tile/{z}/{y}/{x}',\n        options: {\n          attribution: ''\n        }\n      },\n      Imagery: {\n        urlTemplate: tileProtocol + '//server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',\n        options: {\n          attribution: 'DigitalGlobe, GeoEye, i-cubed, USDA, USGS, AEX, Getmapping, Aerogrid, IGN, IGP, swisstopo, and the GIS User Community',\n          attributionUrl: 'https://static.arcgis.com/attribution/World_Imagery'\n        }\n      },\n      ImageryLabels: {\n        urlTemplate: tileProtocol + '//server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}',\n        options: {\n          attribution: ''\n        }\n      },\n      ImageryTransportation: {\n        urlTemplate: tileProtocol + '//server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Transportation/MapServer/tile/{z}/{y}/{x}',\n        options: {\n          attribution: ''\n        }\n      },\n      ShadedRelief: {\n        urlTemplate: tileProtocol + '//server.arcgisonline.com/ArcGIS/rest/services/World_Shaded_Relief/MapServer/tile/{z}/{y}/{x}',\n        options: {\n          attribution: 'USGS'\n        }\n      },\n      ShadedReliefLabels: {\n        urlTemplate: tileProtocol + '//server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places_Alternate/MapServer/tile/{z}/{y}/{x}',\n        options: {\n          attribution: ''\n        }\n      },\n      Terrain: {\n        urlTemplate: tileProtocol + '//server.arcgisonline.com/ArcGIS/rest/services/World_Terrain_Base/MapServer/tile/{z}/{y}/{x}',\n        options: {\n          attribution: 'USGS, NOAA'\n        }\n      },\n      TerrainLabels: {\n        urlTemplate: tileProtocol + '//server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Reference_Overlay/MapServer/tile/{z}/{y}/{x}',\n        options: {\n          attribution: ''\n        }\n      },\n      USATopo: {\n        urlTemplate: tileProtocol + '//server.arcgisonline.com/ArcGIS/rest/services/USA_Topo_Maps/MapServer/tile/{z}/{y}/{x}',\n        options: {\n          attribution: 'USGS, National Geographic Society, i-cubed'\n        }\n      },\n      ImageryClarity: {\n        urlTemplate: tileProtocol + '//clarity.maptiles.arcgis.com/arcgis/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',\n        options: {\n          attribution: 'Esri, DigitalGlobe, GeoEye, Earthstar Geographics, CNES/Airbus DS, USDA, USGS, AeroGRID, IGN, and the GIS User Community'\n        }\n      },\n      Physical: {\n        urlTemplate: tileProtocol + '//server.arcgisonline.com/arcgis/rest/services/World_Physical_Map/MapServer/tile/{z}/{y}/{x}',\n        options: {\n          attribution: 'U.S. National Park Service'\n        }\n      },\n      ImageryFirefly: {\n        urlTemplate: tileProtocol + '//fly.maptiles.arcgis.com/arcgis/rest/services/World_Imagery_Firefly/MapServer/tile/{z}/{y}/{x}',\n        options: {\n          attribution: 'Esri, DigitalGlobe, GeoEye, Earthstar Geographics, CNES/Airbus DS, USDA, USGS, AeroGRID, IGN, and the GIS User Community',\n          attributionUrl: 'https://static.arcgis.com/attribution/World_Imagery'\n        }\n      }\n    };\n\n    if (typeof basemapType === 'string' && tiles[basemapType]) {\n      config = tiles[basemapType];\n    } else {\n      throw new Error('L.viegis.BasemapArcgisLayer: Invalid parameter. Use one of \"Streets\", \"Topographic\", \"Oceans\", \"OceansLabels\", \"NationalGeographic\", \"Physical\", \"Gray\", \"GrayLabels\", \"DarkGray\", \"DarkGrayLabels\", \"Imagery\", \"ImageryLabels\", \"ImageryTransportation\", \"ImageryClarity\", \"ImageryFirefly\", ShadedRelief\", \"ShadedReliefLabels\", \"Terrain\", \"TerrainLabels\" or \"USATopo\"');\n    }\n\n    if (_this.options.token && config.urlTemplate.indexOf('token=') === -1) {\n      config.urlTemplate += '?token=' + _this.options.token;\n    }\n\n    _this.options['attribution'] = config.options.attribution;\n    _this.TileLayer = new leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.tileLayer(config.urlTemplate, _this.options);\n    return _this;\n  }\n  /**\r\n   * @function L.ekmap.BasemapArcgisLayer.prototype.addTo\r\n   * @description Adds the layer to the given map or layer group.\r\n   * @param {L.Map} map - Adds the layer to the given map or layer group.\r\n   * @returns this\r\n   */\n\n\n  _createClass(BasemapArcgisLayer, [{\n    key: \"addTo\",\n    value: function addTo(map) {\n      return this.TileLayer.addTo(map);\n    }\n  }]);\n\n  return BasemapArcgisLayer;\n}(leaflet__WEBPACK_IMPORTED_MODULE_0__[\"TileLayer\"]);\nleaflet__WEBPACK_IMPORTED_MODULE_0___default.a.ekmap.BasemapArcgisLayer = BasemapArcgisLayer;\n\n//# sourceURL=webpack:///./src/leaflet/layer/BasemapArcgisLayer.js?");

/***/ }),

/***/ "./src/leaflet/layer/TileLayer.js":
/*!****************************************!*\
  !*** ./src/leaflet/layer/TileLayer.js ***!
  \****************************************/
/*! exports provided: TileLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TileLayer\", function() { return TileLayer; });\n/* harmony import */ var _core_Util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Util */ \"./src/leaflet/core/Util.js\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! leaflet */ \"leaflet\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_1__);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n/**\r\n * @class L.ekmap.TileLayer\r\n * @classdesc The TileLayer class.\r\n * @category  Layer\r\n * @param {Object} options Construction parameters.\r\n * @param {string} options.url Required: URL of the {@link https://developers.arcgis.com/rest/services-reference/layer-feature-service-.htm|Map Service} with a tile cache.\r\n * @param {string} options.token Will use this token to authenticate all calls to the service.\r\n * @param {string} options.id Id of layer and source.\r\n * @param {string} options.name Name of layer.\r\n * @param {string} options.visibility=visible show or hide layer.\r\n * \r\n */\n\nvar TileLayer = /*#__PURE__*/function () {\n  function TileLayer(options) {\n    _classCallCheck(this, TileLayer);\n\n    this.options = options ? options : {};\n\n    if (options) {\n      options = _core_Util__WEBPACK_IMPORTED_MODULE_0__[\"Util\"].setOptions(this, options); // set the urls\n\n      if (options.url) {\n        options = _core_Util__WEBPACK_IMPORTED_MODULE_0__[\"Util\"].getUrlParams(options);\n        this.tileUrl = (options.proxy ? options.proxy + '?' : '') + options.url + 'tile/{z}/{y}/{x}' + (options.requestParams && Object.keys(options.requestParams).length > 0 ? _core_Util__WEBPACK_IMPORTED_MODULE_0__[\"Util\"].getParamString(options.requestParams) : '');\n\n        if (options.token) {\n          this.tileUrl += '?token=' + options.token;\n        }\n\n        this.tileLayer = new leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.tileLayer(this.tileUrl);\n      }\n    }\n  }\n  /**\r\n   * @function L.ekmap.TileLayer.prototype.addTo\r\n   * @description Adds the layer to the given map or layer group.\r\n   * @param {L.Map} map - Adds the layer to the given map or layer group.\r\n   * @returns this\r\n   */\n\n\n  _createClass(TileLayer, [{\n    key: \"addTo\",\n    value: function addTo(map) {\n      return;\n    }\n  }]);\n\n  return TileLayer;\n}();\nleaflet__WEBPACK_IMPORTED_MODULE_1___default.a.ekmap.TileLayer = TileLayer;\n\n//# sourceURL=webpack:///./src/leaflet/layer/TileLayer.js?");

/***/ }),

/***/ "./src/leaflet/layer/TiledMapLayer.js":
/*!********************************************!*\
  !*** ./src/leaflet/layer/TiledMapLayer.js ***!
  \********************************************/
/*! exports provided: TiledMapLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TiledMapLayer\", function() { return TiledMapLayer; });\n/* harmony import */ var _core_Util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Util */ \"./src/leaflet/core/Util.js\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! leaflet */ \"leaflet\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_1__);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n/**\r\n * @class L.ekmap.TiledMapLayer\r\n * @classdesc The TiledMapLayer class.\r\n * @category  Layer\r\n * @param {Object} options Construction parameters.\r\n * @param {string} options.url Required: URL of the {@link https://developers.arcgis.com/rest/services-reference/layer-feature-service-.htm|Map Service} with a tile cache.\r\n * @param {string} options.token Will use this token to authenticate all calls to the service.\r\n * @param {string} options.attribution Contains an attribution to be displayed when the map is shown to a user.\r\n * @param {string} options.id Id of layer and source.\r\n * @extends {L.TileLayer}\r\n */\n\nvar TiledMapLayer = /*#__PURE__*/function (_TileLayer) {\n  _inherits(TiledMapLayer, _TileLayer);\n\n  var _super = _createSuper(TiledMapLayer);\n\n  function TiledMapLayer(options) {\n    var _this;\n\n    _classCallCheck(this, TiledMapLayer);\n\n    _this = _super.call(this);\n    _this.options = options ? options : {};\n\n    if (options) {\n      options = _core_Util__WEBPACK_IMPORTED_MODULE_0__[\"Util\"].setOptions(_assertThisInitialized(_this), options); // set the urls\n\n      if (options.url) {\n        options = _core_Util__WEBPACK_IMPORTED_MODULE_0__[\"Util\"].getUrlParams(options);\n        _this.tileUrl = (options.proxy ? options.proxy + '?' : '') + options.url + 'tile/{z}/{y}/{x}' + (options.requestParams && Object.keys(options.requestParams).length > 0 ? _core_Util__WEBPACK_IMPORTED_MODULE_0__[\"Util\"].getParamString(options.requestParams) : '');\n        _this.service = new leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.ekmap.MapService(options);\n      }\n\n      if (options.urls) _this.tileUrls = options.urls;\n\n      if (_this.options.token) {\n        _this.tileUrl += '?token=' + _this.options.token;\n      }\n\n      _this.tileLayer = new leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.tileLayer(_this.tileUrl, _this.options);\n    }\n\n    return _this;\n  }\n  /**\r\n   * @function L.ekmap.TiledMapLayer.prototype.addTo\r\n   * @description Adds the layer to the given map or layer group.\r\n   * @param {L.Map} map - Adds the layer to the given map or layer group.\r\n   * @returns this\r\n   */\n\n\n  _createClass(TiledMapLayer, [{\n    key: \"addTo\",\n    value: function addTo(map) {\n      this.tileLayer.addTo(map);\n      return this;\n    }\n    /**\r\n     * @function L.ekmap.TiledMapLayer.prototype.identity\r\n     * @description Returns a new L.ekmap.IdentifyFeatures object that can be used to identify features on this layer. Your callback function will be passed a GeoJSON FeatureCollection with the results or an error.\r\n     * @returns this\r\n     */\n\n  }, {\n    key: \"identify\",\n    value: function identify() {\n      return this.service.identify();\n    }\n    /**\r\n     * @function L.ekmap.TiledMapLayer.prototype.find\r\n     * @description Adds the layer to the given map or layer group.\r\n     * @param {Object} params - Adds the layer to the given map or layer group.\r\n     * @param {RequestCallback} callback \r\n     */\n\n  }, {\n    key: \"find\",\n    value: function find(params, callback, context) {\n      return this.service.find(params, callback, context);\n    }\n    /**\r\n     * @function L.ekmap.TiledMapLayer.prototype.legend\r\n     * @description legend of Tiled Map Layer.\r\n     * @param {RequestCallback} callback\r\n     *\r\n     */\n\n  }, {\n    key: \"legend\",\n    value: function legend(callback, context) {\n      return this.service.legend(callback, context);\n    }\n  }]);\n\n  return TiledMapLayer;\n}(leaflet__WEBPACK_IMPORTED_MODULE_1__[\"TileLayer\"]);\nleaflet__WEBPACK_IMPORTED_MODULE_1___default.a.ekmap.TiledMapLayer = TiledMapLayer;\n\n//# sourceURL=webpack:///./src/leaflet/layer/TiledMapLayer.js?");

/***/ }),

/***/ "./src/leaflet/layer/TiledOSMapLayer.js":
/*!**********************************************!*\
  !*** ./src/leaflet/layer/TiledOSMapLayer.js ***!
  \**********************************************/
/*! exports provided: TiledOSMapLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TiledOSMapLayer\", function() { return TiledOSMapLayer; });\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet */ \"leaflet\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n/**\r\n * @class L.ekmap.TiledOSMapLayer\r\n * @classdesc The TiledOSMapLayer class use url of {@link https://www.openstreetmap.org|openstreetmap}.\r\n * @category Layer\r\n * @param {Object} options - Control options.\r\n * \r\n * @extends {L.TileLayer}\r\n * @example\r\n * var map = new L.Map({\r\n *     container: 'divMapId',\r\n *     center: [103.9, 22.2],\r\n *     zoom: 6\r\n * });\r\n * var OSMap = new L.ekmap.TiledOSMapLayer({\r\n *      token: {YOUR_API_KEY}\r\n * })\r\n *   .addTo(map);\r\n */\n\nvar TiledOSMapLayer = /*#__PURE__*/function (_TileLayer) {\n  _inherits(TiledOSMapLayer, _TileLayer);\n\n  var _super = _createSuper(TiledOSMapLayer);\n\n  function TiledOSMapLayer(options) {\n    var _this;\n\n    _classCallCheck(this, TiledOSMapLayer);\n\n    _this = _super.call(this);\n    _this.options = options ? options : {};\n    _this.url = \"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\";\n    _this.options['attribution'] = \"<a href='https://www.openstreetmap.org/' target='_blank' style='color: blue'>© OpenStreetMap </a>\" + \"contributors\";\n    _this.TileLayer = new leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.tileLayer(_this.url, _this.options);\n    return _this;\n  }\n  /**\r\n   * @function L.ekmap.TiledOSMapLayer.prototype.addTo\r\n   * @description Adds the layer to the given map or layer group.\r\n   * @param {L.Map} map - Adds the layer to the given map or layer group.\r\n   * @returns this\r\n   */\n\n\n  _createClass(TiledOSMapLayer, [{\n    key: \"addTo\",\n    value: function addTo(map) {\n      return this.TileLayer.addTo(map);\n    }\n  }]);\n\n  return TiledOSMapLayer;\n}(leaflet__WEBPACK_IMPORTED_MODULE_0__[\"TileLayer\"]);\nleaflet__WEBPACK_IMPORTED_MODULE_0___default.a.ekmap.TiledOSMapLayer = TiledOSMapLayer;\n\n//# sourceURL=webpack:///./src/leaflet/layer/TiledOSMapLayer.js?");

/***/ }),

/***/ "./src/leaflet/layer/index.js":
/*!************************************!*\
  !*** ./src/leaflet/layer/index.js ***!
  \************************************/
/*! exports provided: TiledMapLayer, TileLayer, TiledOSMapLayer, BasemapArcgisLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _TiledMapLayer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TiledMapLayer */ \"./src/leaflet/layer/TiledMapLayer.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TiledMapLayer\", function() { return _TiledMapLayer__WEBPACK_IMPORTED_MODULE_0__[\"TiledMapLayer\"]; });\n\n/* harmony import */ var _TileLayer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TileLayer */ \"./src/leaflet/layer/TileLayer.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TileLayer\", function() { return _TileLayer__WEBPACK_IMPORTED_MODULE_1__[\"TileLayer\"]; });\n\n/* harmony import */ var _TiledOSMapLayer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TiledOSMapLayer */ \"./src/leaflet/layer/TiledOSMapLayer.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TiledOSMapLayer\", function() { return _TiledOSMapLayer__WEBPACK_IMPORTED_MODULE_2__[\"TiledOSMapLayer\"]; });\n\n/* harmony import */ var _BasemapArcgisLayer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BasemapArcgisLayer */ \"./src/leaflet/layer/BasemapArcgisLayer.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"BasemapArcgisLayer\", function() { return _BasemapArcgisLayer__WEBPACK_IMPORTED_MODULE_3__[\"BasemapArcgisLayer\"]; });\n\n\n\n\n\n\n//# sourceURL=webpack:///./src/leaflet/layer/index.js?");

/***/ }),

/***/ "./src/leaflet/services/FeatureService.js":
/*!************************************************!*\
  !*** ./src/leaflet/services/FeatureService.js ***!
  \************************************************/
/*! exports provided: FeatureService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FeatureService\", function() { return FeatureService; });\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet */ \"leaflet\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Base */ \"./src/leaflet/core/Base.js\");\n/* harmony import */ var _ServiceBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ServiceBase */ \"./src/leaflet/services/ServiceBase.js\");\n/* harmony import */ var _core_Util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Util */ \"./src/leaflet/core/Util.js\");\n/* harmony import */ var _core_Parse__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/Parse */ \"./src/leaflet/core/Parse.js\");\n/* harmony import */ var _turf_turf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @turf/turf */ \"@turf/turf\");\n/* harmony import */ var _turf_turf__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_turf_turf__WEBPACK_IMPORTED_MODULE_5__);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\n\n\n/**\r\n * @class L.ekmap.FeatureService\r\n * @category  BaseType Service\r\n * @classdesc FeatureService.\r\n * @example\r\n * var featureService = new L.ekmap.FeatureService({\r\n *      url : //The URL to the Feature Service\r\n * });\r\n * featureService.query(params,function(result){\r\n *     //doSomething\r\n * })\r\n * @extends {L.ekmap.ServiceBase}\r\n * @param {object} options Construction parameters.\r\n * @param {string} options.url  (Required) The URL to the Feature Service.\r\n * @param {string} options.token - Will use this token to authenticate all calls to the service.\r\n */\n\nvar FeatureService = /*#__PURE__*/function (_ServiceBase) {\n  _inherits(FeatureService, _ServiceBase);\n\n  var _super = _createSuper(FeatureService);\n\n  function FeatureService(options) {\n    var _this;\n\n    _classCallCheck(this, FeatureService);\n\n    _this = _super.call(this, options);\n\n    if (options.url) {\n      _this.options = _core_Util__WEBPACK_IMPORTED_MODULE_3__[\"Util\"].getUrlParams(options);\n    }\n\n    return _this;\n  }\n\n  _createClass(FeatureService, [{\n    key: \"nearby\",\n    value: function nearby(lngLat, callback, context) {\n      var params = {};\n      params.geometry = [lngLat.lng, lngLat.lat];\n      params.geometryType = 'esriGeometryPoint';\n      params.spatialRel = 'esriSpatialRelIntersects';\n      params.units = 'esriSRUnit_Kilometer';\n      params.distance = 5;\n      params.inSr = 4326;\n      params.returnIdsOnly = true;\n      params.f = 'json';\n      var service = new FeatureService(this.options);\n      return service.request('query', params, function (error, response) {\n        callback.call(context, error, response, response);\n      }, this);\n    }\n    /**\r\n     * @function L.ekmap.FeatureService.prototype.run\r\n     * @description  Executes the identify request with the current parameters, identified features will be passed to callback as a GeoJSON FeatureCollection. Accepts an optional function context.\r\n     * @returns {this}\r\n     */\n\n  }, {\n    key: \"run\",\n    value: function run(callback, context) {\n      this._cleanParams();\n\n      var service = new FeatureService(this.options); // services hosted on ArcGIS Online and ArcGIS Server 10.3.1+ support requesting geojson directly\n\n      if (this.options.isModern || isArcgisOnline(this.options.url)) {\n        this.params.f = 'geojson';\n        return service.request('query', params, function (error, response) {\n          this._trapSQLerrors(error);\n\n          callback.call(context, error, response, response);\n        }, this); // otherwise convert it in the callback then pass it on\n      } else {\n        return service.request('query', params, function (error, response) {\n          this._trapSQLerrors(error);\n\n          callback.call(context, error, response && responseToFeatureCollection(response), response);\n        }, this);\n      }\n    }\n    /**\r\n     * @function L.ekmap.FeatureService.prototype.addFeature\r\n     * @description Adds a new feature to the feature layer. this also adds the feature to the map if creation is successful.\r\n     * @param {GeoJSONObject} params GeoJSON of feature add (To change point color, set 'color' for options GeoJSON, the default is light blue ('#3FB1CE')).\r\n     * @param {Function} callback\r\n     * @param {Object} context\r\n     * @returns {this}\r\n     */\n\n  }, {\n    key: \"addFeature\",\n    value: function addFeature(params, callback, context) {\n      this.addFeatures(params, callback, context);\n    }\n    /**\r\n     * @private\r\n     * @function L.ekmap.FeatureService.prototype.addFeatures\r\n     * @description Adds a new feature to the feature layer. this also adds the feature to the map if creation is successful.\r\n     * @param {GeoJSONObject} params GeoJSON of feature add (To change point color, set 'color' for options GeoJSON, the default is light blue ('#3FB1CE')).\r\n     * @param {Function} callback\r\n     * @param {Object} context\r\n     * @returns {this}\r\n     */\n\n  }, {\n    key: \"addFeatures\",\n    value: function addFeatures(params, callback, context) {\n      var fea = _core_Parse__WEBPACK_IMPORTED_MODULE_4__[\"Parse\"].geojsonToArcGIS(params);\n      var data = [];\n      data.push(fea);\n      var dataPost = JSON.stringify(data);\n      var service = new FeatureService(this.options);\n      return service.post('addFeatures', dataPost, function (error, response) {\n        var result = response && response.addResults ? response.addResults.length > 1 ? response.addResults : response.addResults[0] : undefined;\n        callback.call(context, error || response.addResults[0].error, result);\n      }, this);\n    }\n    /**\r\n     * @function L.ekmap.FeatureService.prototype.updateFeature\r\n     * @description Update the provided feature on the Feature Service This also updates the feature on the map. To update the point location on the map. Please use function {@link L.ekmap.FeatureService.html#refresh|refresh()} then update.\r\n     * @param {GeoJSONObject} params Infomation feature.\r\n     * @param {Function} callback The callback of result data returned by the server side.\r\n     * @param {Object} context\r\n     * @returns {this}\r\n     */\n\n  }, {\n    key: \"updateFeature\",\n    value: function updateFeature(params, callback, context) {\n      this.updateFeatures(params, callback, context);\n    }\n    /**\r\n     * @private\r\n     * @function L.ekmap.FeatureService.prototype.updateFeatures\r\n     * @description Update the provided feature on the Feature Layer. This also updates the feature on the map.\r\n     * @param {GeoJSONObject} params - Infomation feature.\r\n     */\n\n  }, {\n    key: \"updateFeatures\",\n    value: function updateFeatures(params, callback, context) {\n      var fea = _core_Parse__WEBPACK_IMPORTED_MODULE_4__[\"Parse\"].geojsonToArcGIS(params);\n      var data = [];\n      data.push(fea);\n      var dataPost = JSON.stringify(data);\n      var service = new FeatureService(this.options);\n      return service.post('updateFeatures', dataPost, function (error, response) {\n        var result = response && response.updateResults ? response.updateResults.length > 1 ? response.updateResults : response.updateResults[0] : undefined;\n        callback.call(context, error || response.updateResults[0].error, result);\n      }, this);\n    }\n    /**\r\n     * @function L.ekmap.FeatureService.prototype.deleteFeature\r\n     * @description Remove the feature with the provided id from the feature layer. This will also remove the feature from the map if it exists. Please use function {@link L.ekmap.FeatureService.html#refresh|refresh()} then delete.\r\n     * @param {Interger} id Id of feature.\r\n     * @param {Function} callback The callback of result data returned by the server side.\r\n     * @param {Object} context\r\n     * @returns {this}\r\n     */\n\n  }, {\n    key: \"deleteFeature\",\n    value: function deleteFeature(id, callback, context) {\n      this.deleteFeatures(id, callback, context);\n    }\n    /**\r\n     * @function L.ekmap.FeatureService.prototype.deleteFeatures\r\n     * @description Removes an array of features with the provided ids from the feature layer. This will also remove the features from the map if they exist.\r\n     * @param {Integers} ids List id of features.\r\n     * @param {Function} callback The callback of result data returned by the server side.\r\n     * @param {Object} context\r\n     * @returns {this}\r\n     */\n\n  }, {\n    key: \"deleteFeatures\",\n    value: function deleteFeatures(ids, callback, context) {\n      var service = new FeatureService(this.options);\n      return service.post('deleteFeatures', ids, function (error, response) {\n        var result = response && response.deleteResults ? response.deleteResults.length > 1 ? response.deleteResults : response.deleteResults[0] : undefined;\n        callback.call(context, error || response.deleteResults[0].error, result);\n      }, this);\n    }\n    /**\r\n     * @function L.ekmap.FeatureService.prototype.query\r\n     * @description Query data\r\n     * @param {Object} params - Adds the layer to the given map or layer group.\r\n     * @param {RequestCallback} callback\r\n     */\n\n  }, {\n    key: \"query\",\n    value: function query(params, callback, context) {\n      var param = {};\n      if (params.where) param.where = params.where;\n      if (params.orderByFields) param.orderByFields = params.orderByFields;\n\n      if (params.layerDefs) {\n        param.f = 'json';\n        param.layerDefs = params.layerDefs;\n      }\n\n      if (params.geometry) {\n        var geom = params.geometry;\n\n        if (params.geometry.type == 'Point') {\n          param.geometryType = 'esriGeometryPoint';\n          param.geometry = {\n            \"x\": geom.coordinates[0],\n            \"y\": geom.coordinates[1],\n            \"spatialReference\": {\n              \"wkid\": 4326\n            }\n          };\n        }\n\n        if (params.geometry.type == 'Polygon') {\n          param.geometryType = 'esriGeometryPolygon';\n          param.geometry = {\n            \"rings\": geom.coordinates,\n            \"spatialReference\": {\n              \"wkid\": 4326\n            }\n          };\n        }\n\n        if (params.geometry.type == 'LineString') param.geometryType = 'esriGeometryPolyline';\n      }\n\n      if (params.objectIds) param.objectIds = params.objectIds;\n\n      if (!params.layerDefs) {\n        param.outFields = '*';\n        param.returnGeometry = true;\n        param.f = 'geojson';\n      }\n\n      var service = new FeatureService(this.options);\n      return service.request('query', param, function (error, response) {\n        if (param.layerDefs) var result = response && response.layers ? response.layers : undefined;else var result = response && response.features ? response.features : undefined;\n        callback.call(context, error, result);\n      }, this);\n    }\n    /**\r\n     * @function L.ekmap.FeatureService.prototype.queryByBound\r\n     * @description  is an abstraction for the find API included in Map Services. It provides a chainable API for building request parameters and executing find tasks.。\r\n     * @param {L.LngLatBounds} lngLatBounds\r\n     * @param {RequestCallback} callback\r\n     */\n\n  }, {\n    key: \"queryByBound\",\n    value: function queryByBound(lngLatBounds, callback, context) {\n      var param = {};\n\n      var data = _core_Util__WEBPACK_IMPORTED_MODULE_3__[\"Util\"]._setGeometry(lngLatBounds);\n\n      param.f = 'geojson';\n      param.outFields = '*';\n      param.geometryType = data.geometryType;\n      param.geometry = data.geometry;\n      var me = this;\n      var service = new FeatureService(this.options);\n      return service.request('query', param, function (error, response) {\n        var result = undefined;\n        if (response && response.features) result = response.features;\n        if (response && response.results) result = response.results;\n        callback.call(context, error, result);\n      }, this);\n    }\n    /**\r\n     * @function L.ekmap.FeatureService.prototype.queryByGeometry\r\n     * @description  is an abstraction for the find API included in Map Services. It provides a chainable API for building request parameters and executing find tasks.。\r\n     * @param {Object} geometry The geometry to apply as the spatial filter. The structure of the geometry is the same as the structure of the JSON geometry objects returned by the ArcGIS REST API. In addition to the JSON structures, for envelopes and points, you can specify the geometry with a simpler comma-separated syntax.\r\n     * @param {RequestCallback} callback\r\n     */\n\n  }, {\n    key: \"queryByGeometry\",\n    value: function queryByGeometry(params, callback, context) {\n      var param = {};\n      var me = this;\n      param.f = 'geojson'; //me.type != undefined ? me.type : 'json'; \n\n      param.outFields = '*';\n\n      if (params) {\n        var geom = params;\n\n        if (params.type == 'Point') {\n          param.geometryType = 'esriGeometryPoint';\n          param.geometry = {\n            \"x\": geom.coordinates[0],\n            \"y\": geom.coordinates[1],\n            \"spatialReference\": {\n              \"wkid\": 4326\n            }\n          };\n        }\n\n        if (params.type == 'Polygon') {\n          param.geometryType = 'esriGeometryPolygon';\n          var arr = geom.coordinates[0];\n          arr.forEach(function (element) {\n            element[0] = Number(element[0].toFixed(6));\n            element[1] = Number(element[1].toFixed(6));\n          });\n          param.geometry = {\n            \"rings\": geom.coordinates,\n            \"spatialReference\": {\n              \"wkid\": 4326\n            }\n          };\n        }\n\n        if (params.type == 'LineString') param.geometryType = 'esriGeometryPolyline';\n      }\n\n      var service = new FeatureService(this.options);\n      return service.request('query', param, function (error, response) {\n        var result = undefined;\n        if (response && response.features) result = response.features;\n        if (response && response.results) result = response.results;\n        callback.call(context, error, result);\n      }, this);\n    }\n    /**\r\n     * @function L.ekmap.FeatureService.prototype.applyEdits\r\n     * @description This operation adds, updates, and deletes features to the associated feature layer.\r\n     * @param {Object} params Options.\r\n     * @param {GeoJSONObject} params.adds GeoJSON of feature add.\r\n     * @param {GeoJSONObject} params.updates GeoJSON of feature update.\r\n     * @param {Interger} params.deletes Id of feature delete.\r\n     * @param {RequestCallback} callback\r\n     */\n\n  }, {\n    key: \"applyEdits\",\n    value: function applyEdits(params, callback, context) {\n      var param = {};\n\n      if (params.adds) {\n        var dataAdd = _core_Parse__WEBPACK_IMPORTED_MODULE_4__[\"Parse\"].geojsonToArcGIS(params.adds);\n        var arr1 = [];\n        arr1.push(dataAdd);\n        param.adds = JSON.stringify(arr1);\n      } else param.adds = false;\n\n      if (params.updates) {\n        var dataUpdate = _core_Parse__WEBPACK_IMPORTED_MODULE_4__[\"Parse\"].geojsonToArcGIS(params.updates);\n        var arr2 = [];\n        arr2.push(dataUpdate);\n        param.updates = JSON.stringify(arr2);\n      } else param.updates = false;\n\n      if (params.deletes) param.deletes = params.deletes;else param.deletes = false;\n      var service = new FeatureService(this.options);\n      return service.post('applyEdits', param, function (error, response) {\n        callback.call(context, error, response, response);\n      }, this);\n    }\n    /**\r\n     * @function L.ekmap.FeatureService.prototype.refresh\r\n     * @description Redraws all features from the feature layer that exist on the map.\r\n     */\n\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      var me = this;\n      var data = {};\n      var params = {\n        where: '1=1'\n      };\n      this.query(params, function (result) {\n        data = {\n          'type': 'FeatureCollection',\n          'features': result\n        };\n\n        if (me.map.getLayer('point')) {\n          me.map.getSource('point').setData(data);\n        }\n\n        if (me.map.getLayer('line')) {\n          me.map.getSource('line').setData(data);\n        }\n\n        if (me.map.getLayer('area')) {\n          me.map.getSource('area').setData(data);\n        }\n      });\n    }\n    /**\r\n     * @function L.ekmap.FeatureService.prototype.on\r\n     * @description On map.\r\n     * @param {L.Map} map The map is defined.\r\n     * @returns {this}\r\n     */\n\n  }, {\n    key: \"on\",\n    value: function on(map) {\n      this.map = map;\n      return this;\n    }\n    /**\r\n     * @function L.ekmap.FeatureService.prototype.param\r\n     * @description param.\r\n     * @param {string} type type.\r\n     * @returns {this}\r\n     */\n\n  }, {\n    key: \"f\",\n    value: function f(type) {\n      this.type = type;\n      return this;\n    }\n    /**\r\n     * @function L.ekmap.FeatureService.prototype.removeFeature\r\n     * @description Remove feature selected.\r\n     */\n\n  }, {\n    key: \"removeFeature\",\n    value: function removeFeature() {\n      var _this2 = this;\n\n      var layers = this.map.getStyle().layers;\n      layers.forEach(function (layer) {\n        if (layer.id.indexOf('queryEK-') != -1) {\n          _this2.map.removeLayer(layer.id);\n        }\n      });\n    }\n  }]);\n\n  return FeatureService;\n}(_ServiceBase__WEBPACK_IMPORTED_MODULE_2__[\"ServiceBase\"]);\nleaflet__WEBPACK_IMPORTED_MODULE_0___default.a.ekmap.FeatureService = FeatureService;\n\n//# sourceURL=webpack:///./src/leaflet/services/FeatureService.js?");

/***/ }),

/***/ "./src/leaflet/services/IdentifyFeatures.js":
/*!**************************************************!*\
  !*** ./src/leaflet/services/IdentifyFeatures.js ***!
  \**************************************************/
/*! exports provided: IdentifyFeatures */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IdentifyFeatures\", function() { return IdentifyFeatures; });\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet */ \"leaflet\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Base */ \"./src/leaflet/core/Base.js\");\n/* harmony import */ var _ServiceBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ServiceBase */ \"./src/leaflet/services/ServiceBase.js\");\n/* harmony import */ var _core_Util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Util */ \"./src/leaflet/core/Util.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\n/**\r\n * @class L.ekmap.IdentifyFeatures\r\n * @category  BaseType Service\r\n * @classdesc  L.ekmap.IdentifyFeatures is an abstraction for the Identify API found in Map Services. It provides a chainable API for building request parameters and executing the request.\r\n * @extends {L.ekmap.ServiceBase}\r\n * @param {object} options Construction parameters.\r\n * @param {string} options.url URL of the ArcGIS service you would like to consume.\r\n * @param {string} options.token - Will use this token to authenticate all calls to the service.\r\n * @example\r\n * var map = new L.Map({\r\n *      container: 'divMapId',\r\n *      center: [103.9, 22.2],\r\n *      zoom: 6\r\n * })\r\n * var identify = new L.ekmap.IdentifyFeatures({\r\n *      url: 'https://viegisserver.ekgis.vn/gserver/rest/services/35/MapServer'\r\n * })\r\n *   .on(map)\r\n *   .at([])\r\n *   .run(function (obj) {\r\n *      console.log();\r\n *   })\r\n *     //doSomething\r\n * })\r\n */\n\nvar IdentifyFeatures = /*#__PURE__*/function (_ServiceBase) {\n  _inherits(IdentifyFeatures, _ServiceBase);\n\n  var _super = _createSuper(IdentifyFeatures);\n\n  function IdentifyFeatures(options) {\n    var _this;\n\n    _classCallCheck(this, IdentifyFeatures);\n\n    _this = _super.call(this, options);\n    if (options.url) _this.options = _core_Util__WEBPACK_IMPORTED_MODULE_3__[\"Util\"].getUrlParams(options);\n    _this.paramsIdentify = {\n      geometry: '',\n      sr: 4326,\n      layers: 'all',\n      tolerance: 6,\n      returnGeometry: true,\n      f: 'json'\n    };\n    return _this;\n  }\n  /**\r\n   * @function L.ekmap.IdentifyFeatures.prototype.on\r\n   * @description  The map to identify features on.\r\n   * @param {L.Map} map The map is defined.\r\n   * @returns {this}\r\n   */\n\n\n  _createClass(IdentifyFeatures, [{\n    key: \"on\",\n    value: function on(map) {\n      var bounds = new leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.LngLatBounds(map.getBounds()._sw, map.getBounds()._ne);\n      var extent = {\n        'xmin': bounds.getSouthWest().lng,\n        'ymin': bounds.getSouthWest().lat,\n        'xmax': bounds.getNorthEast().lng,\n        'ymax': bounds.getNorthEast().lat,\n        'spatialReference': {\n          'wkid': 4326\n        }\n      };\n      var size = map.getContainer();\n      this.paramsIdentify.imageDisplay = [size.clientWidth, size.clientHeight, 96];\n      this.paramsIdentify.mapExtent = [extent.xmin, extent.ymin, extent.xmax, extent.ymax];\n      return this;\n    }\n    /**\r\n     * @function L.ekmap.IdentifyFeatures.prototype.at\r\n     * @description  Identifies features at a given {@link https://docs.mapbox.com/mapbox-gl-js/api/geography/#lnglatbounds|L.LatLngBounds} or a valid GeoJSON object literal.\r\n     * @returns {this}\r\n     */\n\n  }, {\n    key: \"at\",\n    value: function at(geometry) {\n      if (geometry.length === 2) geometry = new leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.LngLat(geometry);\n\n      this._setGeometryParams(geometry);\n\n      return this;\n    }\n    /**\r\n     * @function L.ekmap.IdentifyFeatures.prototype.run\r\n     * @description  Executes the identify request with the current parameters, identified features will be passed to callback as a GeoJSON FeatureCollection. Accepts an optional function context.\r\n     * @returns {this}\r\n     */\n\n  }, {\n    key: \"run\",\n    value: function run(callback, context) {\n      var service = new IdentifyFeatures(this.options);\n      return service.request('identify', this.paramsIdentify, function (error, response) {\n        // immediately invoke with an error\n        callback.call(context, error, response.results);\n      }, this);\n    }\n    /**\r\n     * @private\r\n     * @function L.ekmap.IdentifyFeatures.prototype._setGeometryParams\r\n     * @description Set geometry params.\r\n     */\n\n  }, {\n    key: \"_setGeometryParams\",\n    value: function _setGeometryParams(geometry) {\n      var converted = _core_Util__WEBPACK_IMPORTED_MODULE_3__[\"Util\"]._setGeometry(geometry);\n\n      this.paramsIdentify.geometry = converted.geometry;\n      this.paramsIdentify.geometryType = converted.geometryType;\n    }\n  }]);\n\n  return IdentifyFeatures;\n}(_ServiceBase__WEBPACK_IMPORTED_MODULE_2__[\"ServiceBase\"]);\nleaflet__WEBPACK_IMPORTED_MODULE_0___default.a.ekmap.IdentifyFeatures = IdentifyFeatures;\n\n//# sourceURL=webpack:///./src/leaflet/services/IdentifyFeatures.js?");

/***/ }),

/***/ "./src/leaflet/services/MapService.js":
/*!********************************************!*\
  !*** ./src/leaflet/services/MapService.js ***!
  \********************************************/
/*! exports provided: MapService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MapService\", function() { return MapService; });\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet */ \"leaflet\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Base */ \"./src/leaflet/core/Base.js\");\n/* harmony import */ var _ServiceBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ServiceBase */ \"./src/leaflet/services/ServiceBase.js\");\n/* harmony import */ var _core_Util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Util */ \"./src/leaflet/core/Util.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\n/**\r\n * @class L.ekmap.MapService\r\n * @category  BaseType Service\r\n * @classdesc The MapService class.\r\n * @extends {L.ekmap.ServiceBase}\r\n * @param {object} options Construction parameters.\r\n * @param {string} options.url (Required) The URL to the MapService.\r\n * @param {string} options.token Will use this token to authenticate all calls to the service.\r\n * @example\r\n * var mapService = new L.ekmap.MapService({\r\n *      url: //The URL to the MapService\r\n * });\r\n * mapService.identify(function(result){\r\n *     //doSomething\r\n * })\r\n */\n\nvar MapService = /*#__PURE__*/function (_ServiceBase) {\n  _inherits(MapService, _ServiceBase);\n\n  var _super = _createSuper(MapService);\n\n  function MapService(options) {\n    var _this;\n\n    _classCallCheck(this, MapService);\n\n    _this = _super.call(this, options);\n    _this.options = _core_Util__WEBPACK_IMPORTED_MODULE_3__[\"Util\"].getUrlParams(options);\n    _this.paramsIdentify = {\n      geometry: '',\n      sr: 4326,\n      layers: 'all',\n      tolerance: 3,\n      returnGeometry: true\n    };\n    return _this;\n  }\n  /**\r\n   * @function L.ekmap.MapService.prototype.identify\r\n   * @description Returns a new L.ekmap.IdentifyFeatures object that can be used to identify features contained within this service.\r\n   */\n\n\n  _createClass(MapService, [{\n    key: \"identify\",\n    value: function identify() {\n      return new leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.ekmap.IdentifyFeatures(this.options);\n    }\n    /**\r\n     * @function L.ekmap.MapService.prototype.find\r\n     * @description  Is an abstraction for the find API included in Map Services. It provides a chainable API for building request parameters and executing find tasks.\r\n     * @param {Object} params\r\n     * @param {string} params.f=json The response format. The default response format is html.\r\n     * @param {string} params.searchText (Required) The search string. This is the text that is searched across the layers and fields the user specifies.\r\n     * @param {RequestCallback} callback The callback of result data returned by the server side.\r\n     */\n\n  }, {\n    key: \"find\",\n    value: function find(params, callback, context) {\n      var me = this;\n      this.legend(function (obj) {\n        var layers = [];\n        var list = obj.layers;\n        list.forEach(function (layer) {\n          layers.push(layer.layerId);\n        });\n        var param = {};\n        param.searchText = params.searchText;\n        param.layers = layers.toString();\n        param.f = 'json';\n        var service = new MapService(me.options);\n        return service.request('find', param, function (error, response) {\n          callback.call(context, response.results);\n        }, me);\n      });\n    }\n    /**\r\n     * @function L.ekmap.MapService.prototype.query\r\n     * @description  Is an abstraction for the find API included in Map Services. It provides a chainable API for building request parameters and executing find tasks.。\r\n     * @param {Object} params\r\n     * @param {string} params.f=json The response format. The default response format is json.\r\n     * @param {string} params.where A WHERE clause for the query filter. Any legal SQL WHERE clause operating on the fields in the layer is allowed.\r\n     * @param {string} params.text A literal search text. If the layer has a display field associated with it, the server searches for this text in this field. This parameter is shorthand for a WHERE clause of where <displayField> like '%<text>%'. The text is case sensitive. This parameter is ignored if the WHERE parameter is specified.\r\n     * @param {RequestCallback} callback The callback of result data returned by the server side.\r\n     */\n\n  }, {\n    key: \"query\",\n    value: function query(params, callback, context) {\n      var param = {};\n      param.where = params.where;\n      param.text = params.text;\n      param.objectIds = params.objectId;\n      param.f = 'json';\n      var service = new MapService(this.options);\n      return service.request('query', param, function (error, response) {\n        var result = response && response.features ? response.features : undefined;\n        callback.call(context, error, result);\n      }, this);\n    }\n    /**\r\n     * @function L.ekmap.MapService.prototype.getLayers\r\n     * @description  Get list layer on map. \r\n     * @param {RequestCallback} callback The callback of result data returned by the server side.\r\n     */\n\n  }, {\n    key: \"getLayers\",\n    value: function getLayers(callback, context) {\n      var params = {};\n      params.f = 'json';\n      var service = new MapService(this.options);\n      return service.request('layers', params, function (error, response) {\n        callback.call(context, response);\n      }, this);\n    }\n    /**\r\n     * @function L.ekmap.MapService.prototype.legend\r\n     * @description  Get legend on map.\r\n     * @param {RequestCallback} callback The callback of result data returned by the server side.\r\n     */\n\n  }, {\n    key: \"legend\",\n    value: function legend(callback, context) {\n      var params = {};\n      params.f = 'json';\n      var service = new MapService(this.options);\n      return service.request('legend', params, function (error, response) {\n        console.log(response);\n        callback.call(context, response);\n      }, this);\n    }\n    /**\r\n     * @function L.ekmap.MapService.prototype.queryByBound\r\n     * @description  Is an abstraction for the query API included in Map Services. It provides a chainable API for building request parameters and executing find tasks.\r\n     * @param {L.LngLatBounds} lngLatBounds\r\n     * @param {RequestCallback} callback The callback of result data returned by the server side.\r\n     */\n\n  }, {\n    key: \"queryByBound\",\n    value: function queryByBound(params, callback, context) {\n      var param = {};\n\n      var data = _core_Util__WEBPACK_IMPORTED_MODULE_3__[\"Util\"]._setGeometry(params);\n\n      param.f = 'geojson';\n      param.geometryType = data.geometryType;\n      param.geometry = data.geometry;\n      var me = this;\n      var service = new MapService(this.options);\n      return service.request('query', param, function (error, response) {\n        var result = response && response.features ? response.features : undefined;\n        callback.call(context, error, result);\n      }, this);\n    }\n    /**\r\n     * @function L.ekmap.MapService.prototype.queryByGeometry\r\n     * @description  Is an abstraction for the find API included in Map Services. It provides a chainable API for building request parameters and executing find tasks.。\r\n     * @param {Object} geometry The geometry to apply as the spatial filter. The structure of the geometry is the same as the structure of the JSON geometry objects returned by the ArcGIS REST API. In addition to the JSON structures, for envelopes and points, you can specify the geometry with a simpler comma-separated syntax.\r\n     * @param {RequestCallback} callback The callback of result data returned by the server side.\r\n     */\n\n  }, {\n    key: \"queryByGeometry\",\n    value: function queryByGeometry(params, callback, context) {\n      var param = {};\n      param.f = 'geojson';\n\n      var data = _core_Util__WEBPACK_IMPORTED_MODULE_3__[\"Util\"]._setGeometry(params);\n\n      param.geometryType = data.geometryType;\n      param.geometry = data.geometry;\n      var me = this;\n      var service = new MapService(this.options);\n      return service.request('query', param, function (error, response) {\n        var result = response && response.features ? response.features : undefined;\n        callback.call(context, error, result);\n      }, this);\n    }\n    /**\r\n     * @function L.ekmap.MapService.prototype.on\r\n     * @description On map.\r\n     * @param {L.Map} map The map is defined.\r\n     * @returns {this}\r\n     */\n\n  }, {\n    key: \"on\",\n    value: function on(map) {\n      this.map = map;\n      return this;\n    }\n  }]);\n\n  return MapService;\n}(_ServiceBase__WEBPACK_IMPORTED_MODULE_2__[\"ServiceBase\"]);\nleaflet__WEBPACK_IMPORTED_MODULE_0___default.a.ekmap.MapService = MapService;\n\n//# sourceURL=webpack:///./src/leaflet/services/MapService.js?");

/***/ }),

/***/ "./src/leaflet/services/ServiceBase.js":
/*!*********************************************!*\
  !*** ./src/leaflet/services/ServiceBase.js ***!
  \*********************************************/
/*! exports provided: ServiceBase */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ServiceBase\", function() { return ServiceBase; });\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet */ \"leaflet\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Base */ \"./src/leaflet/core/Base.js\");\n/* harmony import */ var _core_Util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Util */ \"./src/leaflet/core/Util.js\");\n/* harmony import */ var _core_Request__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Request */ \"./src/leaflet/core/Request.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\n/**\r\n * @class L.ekmap.ServiceBase\r\n * @category  BaseType Service\r\n * @description L.ekmap base class.\r\n * @param {Object} options The optional parameters.\r\n * @param {string} options.url (Required) The URL to the MapService.\r\n * @param {string} options.token - Will use this token to authenticate all calls to the service.\r\n * @param {string} options.tokenKey - Will use this token to authenticate all calls to the service.\r\n * @extends {L.Evented}\r\n * \r\n */\n\nvar ServiceBase = /*#__PURE__*/function (_L$Evented) {\n  _inherits(ServiceBase, _L$Evented);\n\n  var _super = _createSuper(ServiceBase);\n\n  function ServiceBase(options) {\n    var _this;\n\n    _classCallCheck(this, ServiceBase);\n\n    _this = _super.call(this, options);\n    _this.options = _core_Util__WEBPACK_IMPORTED_MODULE_2__[\"Util\"].getUrlParams(options);\n    _this.url = _this.options.url;\n    /**\r\n     * @event L.ekmap.ServiceBase#initialized\r\n     * @description .\r\n     * @property {Object} this this .\r\n     */\n\n    _this.fire('initialized', _assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  _createClass(ServiceBase, [{\n    key: \"request\",\n    value: function request(path, params, callback, context) {\n      return this._request(path, params, callback, context);\n    }\n  }, {\n    key: \"_request\",\n    value: function _request(path, params, callback, context) {\n      this.fire('requeststart', {\n        url: this.url + path,\n        params: params\n      }, true);\n\n      if (this.options.token) {\n        params.token = this.options.token;\n      }\n\n      if (this.options.tokenKey) {\n        params.tokenKey = this.options.tokenKey;\n      }\n\n      if (this.options.requestParams) {\n        _core_Util__WEBPACK_IMPORTED_MODULE_2__[\"Util\"].extend(params, this.options.requestParams);\n      }\n\n      if (this._authenticating) {\n        return;\n      } else {\n        var url = this.url + path;\n        return _core_Request__WEBPACK_IMPORTED_MODULE_3__[\"Request\"].send(url + '?' + _core_Util__WEBPACK_IMPORTED_MODULE_2__[\"Util\"].serialize(params), \"\", {}, callback);\n      }\n    }\n  }, {\n    key: \"post\",\n    value: function post(path, dataPost, callback, context) {\n      return this._post(path, dataPost, callback, context);\n    }\n  }, {\n    key: \"_post\",\n    value: function _post(path, dataPost, callback, context) {\n      this.fire('poststart', {\n        url: this.url + path,\n        dataPost: dataPost\n      }, true);\n\n      if (this.options.requestParams) {\n        _core_Util__WEBPACK_IMPORTED_MODULE_2__[\"Util\"].extend(dataPost, this.options.requestParams);\n      }\n\n      var data = {};\n\n      if (this.options.token) {\n        data.token = this.options.token;\n      }\n\n      if (this._authenticating) {\n        this._requestQueue.push([method, path, dataPost, callback, context]);\n\n        return;\n      } else {\n        var url = this.url + path;\n        return _core_Request__WEBPACK_IMPORTED_MODULE_3__[\"Request\"].post(url + '?' + _core_Util__WEBPACK_IMPORTED_MODULE_2__[\"Util\"].serialize(data), dataPost, this.options, callback);\n      }\n    }\n  }, {\n    key: \"_createServiceCallback\",\n    value: function _createServiceCallback(method, path, params, callback, context) {\n      return _core_Util__WEBPACK_IMPORTED_MODULE_2__[\"Util\"].bind(function (error, response) {\n        if (error && (error.code === 499 || error.code === 498)) {\n          this._authenticating = true;\n\n          this._requestQueue.push([method, path, params, callback, context]); // fire an event for users to handle and re-authenticate\n\n\n          this.fire('authenticationrequired', {\n            authenticate: _core_Util__WEBPACK_IMPORTED_MODULE_2__[\"Util\"].bind(this.authenticate, this)\n          }, true); // if the user has access to a callback they can handle the auth error\n\n          error.authenticate = _core_Util__WEBPACK_IMPORTED_MODULE_2__[\"Util\"].bind(this.authenticate, this);\n        }\n\n        callback.call(context, error, response);\n\n        if (error) {\n          this.fire('requesterror', {\n            url: this.options.url + path,\n            params: params,\n            message: error.message,\n            code: error.code,\n            method: method\n          }, true);\n        } else {\n          this.fire('requestsuccess', {\n            url: this.options.url + path,\n            params: params,\n            response: response,\n            method: method\n          }, true);\n        }\n\n        this.fire('requestend', {\n          url: this.options.url + path,\n          params: params,\n          method: method\n        }, true);\n      }, this);\n    }\n  }]);\n\n  return ServiceBase;\n}(leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.Evented);\nleaflet__WEBPACK_IMPORTED_MODULE_0___default.a.ekmap.ServiceBase = ServiceBase;\n\n//# sourceURL=webpack:///./src/leaflet/services/ServiceBase.js?");

/***/ }),

/***/ "./src/leaflet/services/index.js":
/*!***************************************!*\
  !*** ./src/leaflet/services/index.js ***!
  \***************************************/
/*! exports provided: FeatureService, MapService, ServiceBase, IdentifyFeatures */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _FeatureService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FeatureService */ \"./src/leaflet/services/FeatureService.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"FeatureService\", function() { return _FeatureService__WEBPACK_IMPORTED_MODULE_0__[\"FeatureService\"]; });\n\n/* harmony import */ var _MapService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MapService */ \"./src/leaflet/services/MapService.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MapService\", function() { return _MapService__WEBPACK_IMPORTED_MODULE_1__[\"MapService\"]; });\n\n/* harmony import */ var _ServiceBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ServiceBase */ \"./src/leaflet/services/ServiceBase.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ServiceBase\", function() { return _ServiceBase__WEBPACK_IMPORTED_MODULE_2__[\"ServiceBase\"]; });\n\n/* harmony import */ var _IdentifyFeatures__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./IdentifyFeatures */ \"./src/leaflet/services/IdentifyFeatures.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"IdentifyFeatures\", function() { return _IdentifyFeatures__WEBPACK_IMPORTED_MODULE_3__[\"IdentifyFeatures\"]; });\n\n\n\n\n\n\n//# sourceURL=webpack:///./src/leaflet/services/index.js?");

/***/ }),

/***/ 0:
/*!***************************************************************!*\
  !*** multi ./src/leaflet/index.js ./src/leaflet/css/index.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! D:\\Dev\\eKMap\\eKMap-Client\\src\\leaflet\\index.js */\"./src/leaflet/index.js\");\nmodule.exports = __webpack_require__(/*! D:\\Dev\\eKMap\\eKMap-Client\\src\\leaflet\\css\\index.js */\"./src/leaflet/css/index.js\");\n\n\n//# sourceURL=webpack:///multi_./src/leaflet/index.js_./src/leaflet/css/index.js?");

/***/ }),

/***/ "@turf/turf":
/*!********************************************************************!*\
  !*** external "function(){try{return turf}catch(e){return {}}}()" ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(){try{return turf}catch(e){return {}}}();\n\n//# sourceURL=webpack:///external_%22function()%7Btry%7Breturn_turf%7Dcatch(e)%7Breturn_%7B%7D%7D%7D()%22?");

/***/ }),

/***/ "leaflet":
/*!********************!*\
  !*** external "L" ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = L;\n\n//# sourceURL=webpack:///external_%22L%22?");

/***/ })

/******/ });