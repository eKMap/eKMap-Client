/*!
 * 
 *          ekmap-leaflet.(https://ekgis.com.vn/)
 *          Copyright© 2009 - 2020 eKGIS
 *          license: Apache-2.0
 *          version: v0.0.1
 *         
 */!function(e){var r={};function n(t){if(r[t])return r[t].exports;var a=r[t]={i:t,l:!1,exports:{}};return e[t].call(a.exports,a,a.exports,n),a.l=!0,a.exports}n.m=e,n.c=r,n.d=function(e,r,t){n.o(e,r)||Object.defineProperty(e,r,{enumerable:!0,get:t})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,r){if(1&r&&(e=n(e)),8&r)return e;if(4&r&&"object"==typeof e&&e&&e.__esModule)return e;var t=Object.create(null);if(n.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:e}),2&r&&"string"!=typeof e)for(var a in e)n.d(t,a,function(r){return e[r]}.bind(null,a));return t},n.n=function(e){var r=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(r,"a",r),r},n.o=function(e,r){return Object.prototype.hasOwnProperty.call(e,r)},n.p="",n(n.s=0)}({"./src/leaflet/core/Base.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet */ "leaflet");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);\n/**\r\n * @namespace L\r\n * @category BaseType Namespace\r\n */\r\n/**\r\n * @namespace L.ekmap\r\n * @category BaseType Namespace\r\n */\r\n\r\n/**\r\n * @namespace L.ekmap.control\r\n * @category BaseType Namespace\r\n */\r\n\r\n\r\n//thay đổi nội dung\r\nleaflet__WEBPACK_IMPORTED_MODULE_0___default.a.ekmap = leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.ekmap || {};\r\n\r\nleaflet__WEBPACK_IMPORTED_MODULE_0___default.a.ekmap.control = leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.ekmap.control || {};\n\n//# sourceURL=webpack:///./src/leaflet/core/Base.js?')},"./src/leaflet/core/Parse.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Parse\", function() { return Parse; });\nclass Parse {\r\n    static arcgisToGeoJSON(arcgis, idAttribute) {\r\n        var geojson = {};\r\n\r\n        if (arcgis.features) {\r\n            geojson.type = 'FeatureCollection';\r\n            geojson.features = [];\r\n            for (var i = 0; i < arcgis.features.length; i++) {\r\n                geojson.features.push(arcgisToGeoJSON(arcgis.features[i], idAttribute));\r\n            }\r\n        }\r\n\r\n        if (typeof arcgis.x === 'number' && typeof arcgis.y === 'number') {\r\n            geojson.type = 'Point';\r\n            geojson.coordinates = [arcgis.x, arcgis.y];\r\n            if (typeof arcgis.z === 'number') {\r\n                geojson.coordinates.push(arcgis.z);\r\n            }\r\n        }\r\n\r\n        if (arcgis.points) {\r\n            geojson.type = 'MultiPoint';\r\n            geojson.coordinates = arcgis.points.slice(0);\r\n        }\r\n\r\n        if (arcgis.paths) {\r\n            if (arcgis.paths.length === 1) {\r\n                geojson.type = 'LineString';\r\n                geojson.coordinates = arcgis.paths[0].slice(0);\r\n            } else {\r\n                geojson.type = 'MultiLineString';\r\n                geojson.coordinates = arcgis.paths.slice(0);\r\n            }\r\n        }\r\n\r\n        if (arcgis.rings) {\r\n            geojson = convertRingsToGeoJSON(arcgis.rings.slice(0));\r\n        }\r\n\r\n        if (\r\n            typeof arcgis.xmin === 'number' &&\r\n            typeof arcgis.ymin === 'number' &&\r\n            typeof arcgis.xmax === 'number' &&\r\n            typeof arcgis.ymax === 'number'\r\n        ) {\r\n            geojson.type = 'Polygon';\r\n            geojson.coordinates = [\r\n                [\r\n                    [arcgis.xmax, arcgis.ymax],\r\n                    [arcgis.xmin, arcgis.ymax],\r\n                    [arcgis.xmin, arcgis.ymin],\r\n                    [arcgis.xmax, arcgis.ymin],\r\n                    [arcgis.xmax, arcgis.ymax]\r\n                ]\r\n            ];\r\n        }\r\n\r\n        if (arcgis.geometry || arcgis.attributes) {\r\n            geojson.type = 'Feature';\r\n            geojson.geometry = (arcgis.geometry) ? arcgisToGeoJSON(arcgis.geometry) : null;\r\n            geojson.properties = (arcgis.attributes) ? shallowClone(arcgis.attributes) : null;\r\n            if (arcgis.attributes) {\r\n                try {\r\n                    geojson.id = getId(arcgis.attributes, idAttribute);\r\n                } catch (err) {\r\n                    // don't set an id\r\n                }\r\n            }\r\n        }\r\n\r\n        // if no valid geometry was encountered\r\n        if (JSON.stringify(geojson.geometry) === JSON.stringify({})) {\r\n            geojson.geometry = null;\r\n        }\r\n\r\n        if (\r\n            arcgis.spatialReference &&\r\n            arcgis.spatialReference.wkid &&\r\n            arcgis.spatialReference.wkid !== 4326\r\n        ) {\r\n            console.warn('Object converted in non-standard crs - ' + JSON.stringify(arcgis.spatialReference));\r\n        }\r\n\r\n        return geojson;\r\n    }\r\n\r\n    static geojsonToArcGIS(geojson, idAttribute) {\r\n        idAttribute = idAttribute || 'OBJECTID';\r\n        var spatialReference = { wkid: 4326 };\r\n        var result = {};\r\n        var i;\r\n        var geojson = geojson;\r\n        switch (geojson.type) {\r\n            case 'Point':\r\n                result.x = geojson.coordinates[0];\r\n                result.y = geojson.coordinates[1];\r\n                result.spatialReference = spatialReference;\r\n                break;\r\n            case 'MultiPoint':\r\n                result.points = geojson.coordinates.slice(0);\r\n                result.spatialReference = spatialReference;\r\n                break;\r\n            case 'LineString':\r\n                result.paths = [geojson.coordinates.slice(0)];\r\n                result.spatialReference = spatialReference;\r\n                break;\r\n            case 'MultiLineString':\r\n                result.paths = geojson.coordinates.slice(0);\r\n                result.spatialReference = spatialReference;\r\n                break;\r\n            case 'Polygon':\r\n                result.rings = geojson.coordinates;\r\n                result.spatialReference = spatialReference;\r\n                break;\r\n            case 'MultiPolygon':\r\n                result.rings = flattenMultiPolygonRings(geojson.coordinates.slice(0));\r\n                result.spatialReference = spatialReference;\r\n                break;\r\n            case 'Feature':\r\n                if (geojson.geometry && geojson.geometry.type != 'Polyline') {\r\n                    result.geometry = this.geojsonToArcGIS(geojson.geometry, idAttribute);\r\n                }\r\n                if (geojson.properties)\r\n                    result.attributes = (geojson.properties) ? this.shallowClone(geojson.properties) : {};\r\n                //if (geojson.id)\r\n                //    result.attributes[idAttribute] = geojson.id;\r\n                break;\r\n            case 'FeatureCollection':\r\n                result = [];\r\n                for (i = 0; i < geojson.features.length; i++) {\r\n                    result.push(this.geojsonToArcGIS(geojson.features[i], idAttribute));\r\n                }\r\n                break;\r\n            case 'GeometryCollection':\r\n                result = [];\r\n                for (i = 0; i < geojson.geometries.length; i++) {\r\n                    result.push(geojsonToArcGIS(geojson.geometries[i], idAttribute));\r\n                }\r\n                break;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    static shallowClone(obj) {\r\n        var target = {};\r\n        for (var i in obj) {\r\n            if (obj.hasOwnProperty(i)) {\r\n                target[i] = obj[i];\r\n            }\r\n        }\r\n        return target;\r\n    }\r\n}\r\n\r\nL.ekmap.Parse = Parse;\n\n//# sourceURL=webpack:///./src/leaflet/core/Parse.js?")},"./src/leaflet/core/Request.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Request", function() { return Request; });\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet */ "leaflet");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Base */ "./src/leaflet/core/Base.js");\n\r\n\r\n\r\nclass Request {\r\n    static send(url, data, options, callback) {\r\n        options = options || {};\r\n        var self = this;\r\n        // Url\r\n        var encode = (options.encode !== false)\r\n        if (encode) url = encodeURI(url);\r\n        // New request\r\n        var ajax = new XMLHttpRequest();\r\n        ajax.open("GET", url, true);\r\n        if (options.header) {\r\n            for (var header in options.header) {\r\n                ajax.setRequestHeader(header, options.header[header]);\r\n            }\r\n        }\r\n        // Load complete\r\n        //this.dispatchEvent({ type: \'loadstart\' });\r\n        ajax.onload = function() {\r\n            // self._request = null;\r\n            // self.dispatchEvent({ type: \'loadend\' });\r\n            if (this.status >= 200 && this.status < 400) {\r\n                var response;\r\n                var error;\r\n                // Decode response\r\n                try {\r\n                    response = JSON.parse(this.response);\r\n                    // if (response.features) {\r\n                    //     callback(response.features);\r\n                    // }\r\n                    // if (response.results) {\r\n                    //     callback(response.results);\r\n                    // }\r\n                    // if (response.layers) {\r\n                    //     callback(response);\r\n                    // }\r\n                    // if (response.objectIdFieldName && !response.features) {\r\n                    //     callback(response)\r\n                    // }\r\n                    // if (response.osm_type) {\r\n                    //     callback(response)\r\n                    // }\r\n                    // if (response.length > 0 && response[0].osm_type) {\r\n                    //     callback(response)\r\n                    // }\r\n                } catch (e) {\r\n                    response = null;\r\n                    error = {\r\n                        message: \'An error occurred.\'\r\n                    };\r\n                }\r\n                if (!error && response.error) {\r\n                    error = response.error;\r\n                    response = null;\r\n                }\r\n                callback(error, response);\r\n            } else {}\r\n        };\r\n\r\n        // Oops\r\n        ajax.onerror = function() {};\r\n        // GO!\r\n        if (data)\r\n            ajax.send(JSON.stringify(data));\r\n        else\r\n            ajax.send();\r\n    };\r\n\r\n    /** Phương thức GET\r\n     * @param {*} options\r\n     *  @param {string} options.url\r\n     *  @param {string} options.auth Xác thực nếu cần, dạng btoa("username:password");\r\n     *  @param {string} options.dataType Loại dữ liệu trả về, mặc định JSON\r\n     *  @param {string} options.success Hàm callback khi success\r\n     *  @param {string} options.error Hàm callback khi error\r\n     */\r\n    get(options) {\r\n        var ajax = new gclient_ajax(options);\r\n        if (options.success) ajax.on(\'success\', function(e) { options.success(e.response, e); });\r\n        if (options.error) ajax.on(\'error\', function(e) { options.error(e); });\r\n        ajax.send(options.url, options.data, options.options);\r\n    };\r\n\r\n    /** Phương thức POST\r\n     * @param {*} options\r\n     *  @param {string} options.url\r\n     *  @param {string} options.auth Xác thực nếu cần, dạng btoa("username:password");\r\n     *  @param {string} options.dataType Loại dữ liệu trả về, mặc định JSON\r\n     *  @param {string} options.data Dữ liệu POST lên\r\n     *  @param {string} options.success Hàm callback khi success\r\n     *  @param {string} options.error Hàm callback khi error\r\n     */\r\n    static post(url, data, options, callback) {\r\n        options = options || {};\r\n        var encode = (options.encode !== false)\r\n        if (encode) url = encodeURI(url);\r\n        if (data.adds || data.updates || data.deletes) {\r\n            var dataPost = new FormData();\r\n            dataPost.append("f", "json");\r\n            dataPost.append("adds", data.adds);\r\n            dataPost.append("updates", data.updates);\r\n            dataPost.append("deletes", data.deletes);\r\n            if (options.token) dataPost.append("token", options.token)\r\n        } else {\r\n            if (isNaN(data % 2)) {\r\n                var dataPost = new FormData();\r\n                dataPost.append("f", "json");\r\n                dataPost.append("features", data);\r\n                if (options.token) dataPost.append("token", options.token)\r\n            } else {\r\n                var dataPost = new FormData();\r\n                dataPost.append("f", "json");\r\n                dataPost.append("objectIds", data)\r\n                if (options.token) dataPost.append("token", options.token)\r\n            }\r\n        }\r\n        var ajax = new XMLHttpRequest();\r\n        ajax.open("POST", url, false);\r\n        if (options.header) {\r\n            for (var header in options.header) {\r\n                ajax.setRequestHeader("Content-Type", options.header[header]);\r\n            }\r\n        }\r\n        // Load complete\r\n        ajax.onload = function() {\r\n            // self._request = null;\r\n            // self.dispatchEvent({ type: \'loadend\' });\r\n            if (this.status >= 200 && this.status < 400) {\r\n                var response;\r\n                var error;\r\n                // Decode response\r\n                try {\r\n                    response = JSON.parse(this.response);\r\n                } catch (e) {\r\n                    response = null;\r\n                    error = {\r\n                        message: \'An error occurred.\'\r\n                    };\r\n                }\r\n\r\n                if (!error && response.error) {\r\n                    error = response.error;\r\n                    response = null;\r\n                }\r\n                callback(error, response);\r\n            } else {}\r\n        };\r\n\r\n        // Oops\r\n        ajax.onerror = function() {};\r\n        // GO!\r\n        if (dataPost) {\r\n            ajax.send(dataPost);\r\n        } else\r\n            ajax.post();\r\n    };\r\n\r\n    /** Phương thức PUT\r\n     * @param {*} options\r\n     *  @param {string} options.url\r\n     *  @param {string} options.auth Xác thực nếu cần, dạng btoa("username:password");\r\n     *  @param {string} options.dataType Loại dữ liệu trả về, mặc định JSON\r\n     *  @param {string} options.data Dữ liệu PUT lên\r\n     *  @param {string} options.success Hàm callback khi success\r\n     *  @param {string} options.error Hàm callback khi error\r\n     */\r\n    put(options) {\r\n        var ajax = new gclient_ajax(options);\r\n        if (options.success) ajax.on(\'success\', function(e) { options.success(e.response, e); });\r\n        if (options.error) ajax.on(\'error\', function(e) { options.error(e); });\r\n        ajax.send(options.url, options.data, options.options, "PUT");\r\n    };\r\n}\r\n\r\nleaflet__WEBPACK_IMPORTED_MODULE_0___default.a.ekmap.Request = Request;\n\n//# sourceURL=webpack:///./src/leaflet/core/Request.js?')},"./src/leaflet/core/Util.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Util\", function() { return Util; });\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet */ \"leaflet\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Base */ \"./src/leaflet/core/Base.js\");\n/* harmony import */ var _core_Parse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Parse */ \"./src/leaflet/core/Parse.js\");\n\r\n\r\n\r\n\r\n/**\r\n * @class mapboxgl.ekmap.Util\r\n * @category BaseType Util\r\n * @classdesc The tool class.\r\n */\r\nclass Util {\r\n\r\n    static isNumber(value) {\r\n        if (value === \"\") {\r\n            return false;\r\n        }\r\n        let mdata = Number(value);\r\n        if (mdata === 0) {\r\n            return true;\r\n        }\r\n        return !isNaN(mdata);\r\n    }\r\n\r\n    static isString(str) {\r\n        return (typeof str === 'string') && str.constructor === String;\r\n    }\r\n\r\n    static newGuid(attr) {\r\n        let len = attr || 32;\r\n        let guid = \"\";\r\n        for (let i = 1; i < len; i++) {\r\n            let n = Math.floor(Math.random() * 16.0).toString(16);\r\n            guid += n;\r\n        }\r\n        return guid;\r\n    }\r\n\r\n    static hexToRgba(hex, opacity) {\r\n        var color = [],\r\n            rgba = [];\r\n        hex = hex.replace(/#/, \"\");\r\n        if (hex.length == 3) {\r\n            var tmp = [];\r\n            for (let i = 0; i < 3; i++) {\r\n                tmp.push(hex.charAt(i) + hex.charAt(i));\r\n            }\r\n            hex = tmp.join(\"\");\r\n        }\r\n        for (let i = 0; i < 6; i += 2) {\r\n            color[i] = \"0x\" + hex.substr(i, 2);\r\n            rgba.push(parseInt(Number(color[i])));\r\n        }\r\n        rgba.push(opacity);\r\n        return \"rgba(\" + rgba.join(\",\") + \")\";\r\n    }\r\n\r\n    static bind(fn, obj) {\r\n        var slice = Array.prototype.slice;\r\n\r\n        if (fn.bind) {\r\n            return fn.bind.apply(fn, slice.call(arguments, 1));\r\n        }\r\n\r\n        var args = slice.call(arguments, 2);\r\n\r\n        return function() {\r\n            return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);\r\n        };\r\n    }\r\n\r\n    static serialize(params) {\r\n        var data = '';\r\n        var i = 0;\r\n        params.f = params.f || 'json';\r\n        for (var key in params) {\r\n            i++;\r\n            if (params.hasOwnProperty(key)) {\r\n                var param = params[key];\r\n                var type = Object.prototype.toString.call(param);\r\n                var value;\r\n                if (data.length) {\r\n                    data += '&';\r\n                }\r\n                if (type === '[object Array]') {\r\n                    value = (Object.prototype.toString.call(param[0]) === '[object Object]') ? JSON.stringify(param) : param.join(',');\r\n                } else if (type === '[object Object]') {\r\n                    value = JSON.stringify(param);\r\n                } else if (type === '[object Date]') {\r\n                    value = param.valueOf();\r\n                } else {\r\n                    var param = param + '';\r\n                    if (param.indexOf(':') && key != 'layerDefs')\r\n                        param = param.replace(\":\", \"%3A\");\r\n                    if (param.indexOf('/'))\r\n                        param = param.replace(\"/\", \"%2F\");\r\n                    value = param;\r\n                }\r\n                data += encodeURIComponent(key) + '=' + value;\r\n            }\r\n        }\r\n        return data;\r\n    }\r\n\r\n    static _setGeometry(geometry) {\r\n        var params = {\r\n            geometry: null,\r\n            geometryType: null\r\n        };\r\n        if (geometry instanceof mapboxgl.LngLat) {\r\n            geometry = {\r\n                type: 'Point',\r\n                coordinates: [geometry.lng, geometry.lat]\r\n            };\r\n        }\r\n\r\n        if (geometry instanceof mapboxgl.LngLatBounds) {\r\n            // set geometry + geometryType\r\n            params.geometry = this.boundsToExtent(geometry);\r\n            params.geometryType = 'esriGeometryEnvelope';\r\n            return params;\r\n        }\r\n\r\n        // confirm that our GeoJSON is a point, line or polygon\r\n        if (geometry.type === 'Point' || geometry.type === 'LineString' || geometry.type === 'Polygon' || geometry.type === 'MultiPolygon') {\r\n            params.geometry = _core_Parse__WEBPACK_IMPORTED_MODULE_2__[\"Parse\"].geojsonToArcGIS(geometry);\r\n            params.geometryType = this.geojsonTypeToArcGIS(geometry.type);\r\n            return params;\r\n        }\r\n\r\n        // convert L.Marker > L.LatLng\r\n        if (geometry.getLatLng) {\r\n            geometry = geometry.getLatLng();\r\n        }\r\n        // handle L.GeoJSON, pull out the first geometry\r\n        //if (geometry instanceof GeoJSON) {\r\n        //    // reassign geometry to the GeoJSON value  (we are assuming that only one feature is present)\r\n        //    geometry = geometry.getLayers()[0].feature.geometry;\r\n        //    params.geometry = geojsonToArcGIS(geometry);\r\n        //    params.geometryType = geojsonTypeToArcGIS(geometry.type);\r\n        //}\r\n\r\n        // Handle L.Polyline and L.Polygon\r\n        //if (geometry.toGeoJSON) {\r\n        //    geometry = geometry.toGeoJSON();\r\n        //}\r\n\r\n        // handle GeoJSON feature by pulling out the geometry\r\n        if (geometry.type === 'Feature') {\r\n            // get the geometry of the geojson feature\r\n            geometry = geometry.geometry;\r\n        }\r\n\r\n    }\r\n\r\n    static boundsToExtent(bounds) {\r\n        return {\r\n            'xmin': bounds.getSouthWest().lng,\r\n            'ymin': bounds.getSouthWest().lat,\r\n            'xmax': bounds.getNorthEast().lng,\r\n            'ymax': bounds.getNorthEast().lat,\r\n            'spatialReference': {\r\n                'wkid': 4326\r\n            }\r\n        };\r\n    }\r\n\r\n    static geojsonTypeToArcGIS(geoJsonType) {\r\n        var arcgisGeometryType;\r\n        switch (geoJsonType) {\r\n            case 'Point':\r\n                arcgisGeometryType = 'esriGeometryPoint';\r\n                break;\r\n            case 'MultiPoint':\r\n                arcgisGeometryType = 'esriGeometryMultipoint';\r\n                break;\r\n            case 'LineString':\r\n                arcgisGeometryType = 'esriGeometryPolyline';\r\n                break;\r\n            case 'MultiLineString':\r\n                arcgisGeometryType = 'esriGeometryPolyline';\r\n                break;\r\n            case 'Polygon':\r\n                arcgisGeometryType = 'esriGeometryPolygon';\r\n                break;\r\n            case 'MultiPolygon':\r\n                arcgisGeometryType = 'esriGeometryPolygon';\r\n                break;\r\n        }\r\n\r\n        return arcgisGeometryType;\r\n    }\r\n\r\n    static isArray(obj) {\r\n        return (Object.prototype.toString.call(obj) === '[object Array]');\r\n    };\r\n\r\n    static setOptions(obj, options) {\r\n        if (!Object.prototype.hasOwnProperty.call(obj, 'options')) {\r\n            obj.options = obj.options ? create(obj.options) : {};\r\n        }\r\n        for (var i in options) {\r\n            obj.options[i] = options[i];\r\n        }\r\n        return obj.options;\r\n    }\r\n\r\n    static getUrlParams(options) {\r\n        if (options.url) {\r\n            if (options.url.indexOf('?') !== -1) {\r\n                options.requestParams = options.requestParams || {};\r\n                var queryString = options.url.substring(options.url.indexOf('?') + 1);\r\n                options.url = options.url.split('?')[0];\r\n                options.requestParams = JSON.parse('{\"' + decodeURI(queryString).replace(/\"/g, '\\\\\"').replace(/&/g, '\",\"').replace(/=/g, '\":\"') + '\"}');\r\n            }\r\n            options.url = this.cleanUrl(options.url.split('?')[0]);\r\n        }\r\n        return options;\r\n    }\r\n\r\n    static getUrl(options) {\r\n        if (options.url.indexOf('/0') != '-1')\r\n            option.url = options.url.split('/0').join('');\r\n        if (options.url.indexOf('/1') != '-1')\r\n            option.url = options.url.split('/1').join('');\r\n        if (options.url.indexOf('/2') != '-1')\r\n            option.url = options.url.split('/2').join('');\r\n        if (options.url.indexOf('/3') != '-1')\r\n            option.url = options.url.split('/3').join('');\r\n        return options;\r\n    }\r\n\r\n    static getUrlsParams(options) {\r\n        var string = options.urls.split(\".\")[0];\r\n        var indexCut = string.indexOf(\"{\") - 1;\r\n        var stringCut = string.split(string[indexCut])[2];\r\n        var urls = [];\r\n        for (var i = stringCut[1]; i <= stringCut[3]; i++)\r\n            urls.push(options.urls.split(stringCut).join(i));\r\n        options.urls = urls\r\n        return options;\r\n    }\r\n\r\n    static cleanUrl(url) {\r\n        // trim leading and trailing spaces, but not spaces inside the url\r\n        // add a trailing slash to the url if the user omitted it\r\n        if (url[url.length - 1] !== '/') {\r\n            url += '/';\r\n        }\r\n        return url;\r\n    }\r\n\r\n    static splitWords(str) {\r\n        return this.trim(str).split(/\\s+/);\r\n    }\r\n\r\n    static trim(str) {\r\n        return str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\r\n    }\r\n\r\n\r\n\r\n    // @function stamp(obj: Object): Number\r\n    // Returns the unique ID of an object, assigning it one if it doesn't have it.\r\n    static stamp(obj) {\r\n        /*eslint-disable */\r\n        var lastId = 0;\r\n        obj._leaflet_id = obj._leaflet_id || ++lastId;\r\n        return obj._leaflet_id;\r\n        /* eslint-enable */\r\n    }\r\n\r\n    static bind(fn, obj) {\r\n        var slice = Array.prototype.slice;\r\n\r\n        if (fn.bind) {\r\n            return fn.bind.apply(fn, slice.call(arguments, 1));\r\n        }\r\n\r\n        var args = slice.call(arguments, 2);\r\n\r\n        return function() {\r\n            return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);\r\n        };\r\n    }\r\n\r\n    static cancelAnimFrame(id) {\r\n        var cancelFn = window.cancelAnimationFrame || this.getPrefixed('CancelAnimationFrame') ||\r\n            this.getPrefixed('CancelRequestAnimationFrame') || function(id) { window.clearTimeout(id); };\r\n        if (id) {\r\n            cancelFn.call(window, id);\r\n        }\r\n    }\r\n\r\n    static getPrefixed(name) {\r\n        return window['webkit' + name] || window['moz' + name] || window['ms' + name];\r\n    }\r\n\r\n    static formatNum(num, digits) {\r\n        var pow = Math.pow(10, (digits === undefined ? 6 : digits));\r\n        return Math.round(num * pow) / pow;\r\n    }\r\n\r\n    static extend(dest) {\r\n        var i, j, len, src;\r\n\r\n        for (j = 1, len = arguments.length; j < len; j++) {\r\n            src = arguments[j];\r\n            for (i in src) {\r\n                dest[i] = src[i];\r\n            }\r\n        }\r\n        return dest;\r\n    }\r\n\r\n    static deepClone(obj) {\r\n        let cloned = {};\r\n        if (typeof obj !== 'object') return obj;\r\n        if (obj instanceof Array) return obj.map((ele) => this.deepClone(ele));\r\n        for (let k in obj) {\r\n            if (obj.hasOwnProperty(k) && typeof obj[k] !== 'object') {\r\n                cloned[k] = obj[k];\r\n            } else if (obj[k].constructor.toString().indexOf(\"Object\") > 0) {\r\n                cloned[k] = this.deepClone(obj[k]);\r\n            } else if (Array.isArray(obj[k])) {\r\n                cloned[k] = obj[k].map((ele) => {\r\n                    // let ret = null;\r\n                    if (typeof ele !== 'object') return ele;\r\n                    else return this.deepClone(ele);\r\n                });\r\n                // cloned[k] = [].concat(obj[k]);\r\n            }\r\n        }\r\n        return cloned;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @description add img, video element to domContainer.\r\n     * @param {Array} dom dom container..\r\n     * @param {Array} res urls of img/video loaded to dom.\r\n     */\r\n    static setResource(dom, res) {\r\n        if (!(res instanceof Array)) return;\r\n        dom.innerHTML = '';\r\n        for (let i = 0; i < res.length; i++) {\r\n            let filetype = this.getFiletype(res[i]);\r\n            if (filetype !== \"\") {\r\n                let ele = document.createElement(filetype);\r\n                ele.style.width = ele.style.height = dom.style.width = dom.style.height = '60px';\r\n                ele.style.borderRadius = \"50%\";\r\n                ele.src = res[i];\r\n                dom.style.borderRadius = \"50%\";\r\n                dom.appendChild(ele);\r\n            }\r\n            if (filetype == 'video') {\r\n                ele.setAttribute('autoplay', true);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * return iconposition style by iconName\r\n     */\r\n    static setIconDiv(dom, iconName) {\r\n        let icons = Const.Sprites;\r\n        if (iconName && icons[iconName]) {\r\n            let iconStyle = icons[iconName],\r\n                iconDiv = document.createElement(\"div\");\r\n            iconDiv.style.width = iconStyle.width + \"px\";\r\n            iconDiv.style.height = iconStyle.height + \"px\";\r\n            iconDiv.style.overflow = 'hidden';\r\n            let iconImg = document.createElement(\"img\");\r\n            iconImg.src = Const.SpritesUrl + \".png\";\r\n            iconImg.style.marginLeft = \"-\" + iconStyle.x + \"px\";\r\n            iconImg.style.marginTop = \"-\" + iconStyle.y + \"px\";\r\n            iconDiv.appendChild(iconImg);\r\n            dom.appendChild(iconDiv);\r\n        }\r\n    }\r\n\r\n    static isChanged(lastData, data) {\r\n        if (JSON.stringify(lastData) == JSON.stringify(data))\r\n            return false;\r\n        else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    static setChart(dom, data, type, height, backgroundColor) {\r\n        if (!Chart) {\r\n            return;\r\n        }\r\n        let canv = document.createElement('canvas'),\r\n            ctx = canv.getContext('2d');\r\n        if (type == 'bar')\r\n            canv.style.backgroundColor = backgroundColor ? backgroundColor : 'rgb(245, 222, 179)';\r\n        else\r\n            canv.style.backgroundColor = 'rgba(0,0,0,0.0)';\r\n\r\n        let chart = new Chart(ctx, {\r\n            type: type,\r\n            data: data,\r\n            options: {\r\n                legend: {\r\n                    display: false\r\n                },\r\n                // plugins: {\r\n                //     labels: {\r\n                //         render: function (args) {\r\n                //             return args.value;\r\n                //         },\r\n                //         fontSize: 10,\r\n                //         fontStyle: 'normal',\r\n                //         fontColor: '#fff',\r\n                //         fontFamily: '\"Lucida Console\", Monaco, monospace'\r\n                //     }\r\n                // }\r\n            }\r\n        });\r\n        canv.height = height;\r\n        canv.style.height = canv.height + 'px';\r\n        canv.width = height;\r\n        canv.style.width = canv.width + 'px';\r\n        dom.appendChild(canv);\r\n        return chart;\r\n    }\r\n\r\n    static getParamString(obj, existingUrl, uppercase) {\r\n        var params = [];\r\n        for (var i in obj) {\r\n            params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));\r\n        }\r\n        return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');\r\n    }\r\n\r\n    static getSourceId(map) {\r\n        var layers = map.getStyle().layers;\r\n        var idCheck = layers[0].id % 2;\r\n        if (!isNaN(idCheck)) {\r\n            var lay = map.getLayer(layers[0].id);\r\n            return lay.source;\r\n        }\r\n    }\r\n}\r\n\r\nleaflet__WEBPACK_IMPORTED_MODULE_0___default.a.ekmap.Util = Util;\n\n//# sourceURL=webpack:///./src/leaflet/core/Util.js?")},"./src/leaflet/core/index.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Util */ "./src/leaflet/core/Util.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Util", function() { return _Util__WEBPACK_IMPORTED_MODULE_0__["Util"]; });\n\n/* harmony import */ var _Parse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Parse */ "./src/leaflet/core/Parse.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Parse", function() { return _Parse__WEBPACK_IMPORTED_MODULE_1__["Parse"]; });\n\n/* harmony import */ var _Request__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Request */ "./src/leaflet/core/Request.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Request", function() { return _Request__WEBPACK_IMPORTED_MODULE_2__["Request"]; });\n\n\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack:///./src/leaflet/core/index.js?')},"./src/leaflet/css/index.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./style */ "./src/leaflet/css/style.css");\n/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style__WEBPACK_IMPORTED_MODULE_0__);\n\n\n//# sourceURL=webpack:///./src/leaflet/css/index.js?')},"./src/leaflet/css/style.css":function(module,exports){eval("// removed by extract-text-webpack-plugin\n\n//# sourceURL=webpack:///./src/leaflet/css/style.css?")},"./src/leaflet/index.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _layer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./layer */ "./src/leaflet/layer/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TiledMapLayer", function() { return _layer__WEBPACK_IMPORTED_MODULE_0__["TiledMapLayer"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TiledOSMapLayer", function() { return _layer__WEBPACK_IMPORTED_MODULE_0__["TiledOSMapLayer"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BasemapArcgisLayer", function() { return _layer__WEBPACK_IMPORTED_MODULE_0__["BasemapArcgisLayer"]; });\n\n/* harmony import */ var _services__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./services */ "./src/leaflet/services/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MapService", function() { return _services__WEBPACK_IMPORTED_MODULE_1__["MapService"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ServiceBase", function() { return _services__WEBPACK_IMPORTED_MODULE_1__["ServiceBase"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FeatureService", function() { return _services__WEBPACK_IMPORTED_MODULE_1__["FeatureService"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "IdentifyFeatures", function() { return _services__WEBPACK_IMPORTED_MODULE_1__["IdentifyFeatures"]; });\n\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core */ "./src/leaflet/core/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Request", function() { return _core__WEBPACK_IMPORTED_MODULE_2__["Request"]; });\n\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// export * from \'./control\';\r\n// export * from \'./core\';\r\n// export * from \'./layer\';\r\n// export * from \'./services\';\n\n//# sourceURL=webpack:///./src/leaflet/index.js?')},"./src/leaflet/layer/BasemapArcgisLayer.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BasemapArcgisLayer\", function() { return BasemapArcgisLayer; });\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet */ \"leaflet\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);\n\r\n\r\n\r\n/**\r\n * @class L.ekmap.BasemapArcgisLayer\r\n * @classdesc The BasemapArcgisLayer class use some arcgis layer and url of them from {@link https://github.com/Esri/esri-leaflet/blob/master/src/Layers/BasemapLayer.js|source}.\r\n * @category  Layer\r\n * @param {string} basemapType basemapType refers to the specific basemap you'd like to add. <br>Use one of \"Streets\", \"Topographic\", \"Oceans\", \"OceansLabels\", \"NationalGeographic\", \"Physical\", \"Gray\", \"GrayLabels\", \"DarkGray\", \"DarkGrayLabels\", \"Imagery\", \"ImageryLabels\", \"ImageryTransportation\", \"ImageryClarity\", \"ImageryFirefly\", ShadedRelief\", \"ShadedReliefLabels\", \"Terrain\", \"TerrainLabels\" or \"USATopo\".\r\n * @extends {L.TileLayer}\r\n * @example\r\n * var map = new L.Map({\r\n *     container: 'map1',\r\n *     center: [103.9, 22.2],\r\n *     zoom: 6\r\n * });\r\n * var baseMap = new L.ekmap.BasemapArcgisLayer('Topographic')\r\n *   .addTo(map);\r\n */\r\n\r\nvar tileProtocol = (window.location.protocol !== 'https:') ? 'http:' : 'https:';\r\n\r\nclass BasemapArcgisLayer extends leaflet__WEBPACK_IMPORTED_MODULE_0__[\"TileLayer\"] {\r\n\r\n    constructor(basemapType, options) {\r\n        super();\r\n        this.options = options ? options : {};\r\n        var config;\r\n        var tiles = {\r\n            Streets: {\r\n                urlTemplate: tileProtocol + '//server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}',\r\n                options: {\r\n                    attribution: 'USGS, NOAA',\r\n                    attributionUrl: 'https://static.arcgis.com/attribution/World_Street_Map'\r\n                }\r\n            },\r\n            Topographic: {\r\n                urlTemplate: tileProtocol + '//server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}',\r\n                options: {\r\n                    attribution: 'USGS, NOAA',\r\n                    attributionUrl: 'https://static.arcgis.com/attribution/World_Topo_Map'\r\n                }\r\n            },\r\n            Oceans: {\r\n                urlTemplate: tileProtocol + '//server.arcgisonline.com/arcgis/rest/services/Ocean/World_Ocean_Base/MapServer/tile/{z}/{y}/{x}',\r\n                options: {\r\n                    attribution: 'USGS, NOAA',\r\n                    attributionUrl: 'https://static.arcgis.com/attribution/Ocean_Basemap'\r\n                }\r\n            },\r\n            OceansLabels: {\r\n                urlTemplate: tileProtocol + '//server.arcgisonline.com/arcgis/rest/services/Ocean/World_Ocean_Reference/MapServer/tile/{z}/{y}/{x}',\r\n                options: {\r\n                    attribution: ''\r\n                }\r\n            },\r\n            NationalGeographic: {\r\n                urlTemplate: tileProtocol + '//server.arcgisonline.com/ArcGIS/rest/services/NatGeo_World_Map/MapServer/tile/{z}/{y}/{x}',\r\n                options: {\r\n                    attribution: 'National Geographic, DeLorme, HERE, UNEP-WCMC, USGS, NASA, ESA, METI, NRCAN, GEBCO, NOAA, increment P Corp.'\r\n                }\r\n            },\r\n            DarkGray: {\r\n                urlTemplate: tileProtocol + '//server.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Dark_Gray_Base/MapServer/tile/{z}/{y}/{x}',\r\n                options: {\r\n                    attribution: 'HERE, DeLorme, MapmyIndia, &copy; OpenStreetMap contributors'\r\n                }\r\n            },\r\n            DarkGrayLabels: {\r\n                urlTemplate: tileProtocol + '//server.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Dark_Gray_Reference/MapServer/tile/{z}/{y}/{x}',\r\n                options: {\r\n                    attribution: ''\r\n                }\r\n            },\r\n            Gray: {\r\n                urlTemplate: tileProtocol + '//server.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Base/MapServer/tile/{z}/{y}/{x}',\r\n                options: {\r\n                    attribution: 'HERE, DeLorme, MapmyIndia, &copy; OpenStreetMap contributors'\r\n                }\r\n            },\r\n            GrayLabels: {\r\n                urlTemplate: tileProtocol + '//server.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Reference/MapServer/tile/{z}/{y}/{x}',\r\n                options: {\r\n                    attribution: ''\r\n                }\r\n            },\r\n            Imagery: {\r\n                urlTemplate: tileProtocol + '//server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',\r\n                options: {\r\n                    attribution: 'DigitalGlobe, GeoEye, i-cubed, USDA, USGS, AEX, Getmapping, Aerogrid, IGN, IGP, swisstopo, and the GIS User Community',\r\n                    attributionUrl: 'https://static.arcgis.com/attribution/World_Imagery'\r\n                }\r\n            },\r\n            ImageryLabels: {\r\n                urlTemplate: tileProtocol + '//server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}',\r\n                options: {\r\n                    attribution: ''\r\n                }\r\n            },\r\n            ImageryTransportation: {\r\n                urlTemplate: tileProtocol + '//server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Transportation/MapServer/tile/{z}/{y}/{x}',\r\n                options: {\r\n                    attribution: ''\r\n                }\r\n            },\r\n            ShadedRelief: {\r\n                urlTemplate: tileProtocol + '//server.arcgisonline.com/ArcGIS/rest/services/World_Shaded_Relief/MapServer/tile/{z}/{y}/{x}',\r\n                options: {\r\n                    attribution: 'USGS'\r\n                }\r\n            },\r\n            ShadedReliefLabels: {\r\n                urlTemplate: tileProtocol + '//server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places_Alternate/MapServer/tile/{z}/{y}/{x}',\r\n                options: {\r\n                    attribution: ''\r\n                }\r\n            },\r\n            Terrain: {\r\n                urlTemplate: tileProtocol + '//server.arcgisonline.com/ArcGIS/rest/services/World_Terrain_Base/MapServer/tile/{z}/{y}/{x}',\r\n                options: {\r\n                    attribution: 'USGS, NOAA'\r\n                }\r\n            },\r\n            TerrainLabels: {\r\n                urlTemplate: tileProtocol + '//server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Reference_Overlay/MapServer/tile/{z}/{y}/{x}',\r\n                options: {\r\n                    attribution: ''\r\n                }\r\n            },\r\n            USATopo: {\r\n                urlTemplate: tileProtocol + '//server.arcgisonline.com/ArcGIS/rest/services/USA_Topo_Maps/MapServer/tile/{z}/{y}/{x}',\r\n                options: {\r\n                    attribution: 'USGS, National Geographic Society, i-cubed'\r\n                }\r\n            },\r\n            ImageryClarity: {\r\n                urlTemplate: tileProtocol + '//clarity.maptiles.arcgis.com/arcgis/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',\r\n                options: {\r\n                    attribution: 'Esri, DigitalGlobe, GeoEye, Earthstar Geographics, CNES/Airbus DS, USDA, USGS, AeroGRID, IGN, and the GIS User Community'\r\n                }\r\n            },\r\n            Physical: {\r\n                urlTemplate: tileProtocol + '//server.arcgisonline.com/arcgis/rest/services/World_Physical_Map/MapServer/tile/{z}/{y}/{x}',\r\n                options: {\r\n                    attribution: 'U.S. National Park Service'\r\n                }\r\n            },\r\n            ImageryFirefly: {\r\n                urlTemplate: tileProtocol + '//fly.maptiles.arcgis.com/arcgis/rest/services/World_Imagery_Firefly/MapServer/tile/{z}/{y}/{x}',\r\n                options: {\r\n                    attribution: 'Esri, DigitalGlobe, GeoEye, Earthstar Geographics, CNES/Airbus DS, USDA, USGS, AeroGRID, IGN, and the GIS User Community',\r\n                    attributionUrl: 'https://static.arcgis.com/attribution/World_Imagery'\r\n                }\r\n            }\r\n        }\r\n        if (typeof basemapType === 'string' && tiles[basemapType]) {\r\n            config = tiles[basemapType];\r\n        } else {\r\n            throw new Error('L.viegis.BasemapArcgisLayer: Invalid parameter. Use one of \"Streets\", \"Topographic\", \"Oceans\", \"OceansLabels\", \"NationalGeographic\", \"Physical\", \"Gray\", \"GrayLabels\", \"DarkGray\", \"DarkGrayLabels\", \"Imagery\", \"ImageryLabels\", \"ImageryTransportation\", \"ImageryClarity\", \"ImageryFirefly\", ShadedRelief\", \"ShadedReliefLabels\", \"Terrain\", \"TerrainLabels\" or \"USATopo\"');\r\n        }\r\n        if (this.options.token && config.urlTemplate.indexOf('token=') === -1) {\r\n            config.urlTemplate += ('?token=' + this.options.token);\r\n        }\r\n        this.options['attribution'] = config.options.attribution;\r\n        this.TileLayer = new leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.tileLayer(config.urlTemplate, this.options)\r\n\r\n    }\r\n\r\n    /**\r\n     * @function L.ekmap.BasemapArcgisLayer.prototype.addTo\r\n     * @description Adds the layer to the given map or layer group.\r\n     * @param {L.Map} map - Adds the layer to the given map or layer group.\r\n     * @returns this\r\n     */\r\n    addTo(map) {\r\n        return this.TileLayer.addTo(map);\r\n    }\r\n}\r\n\r\nleaflet__WEBPACK_IMPORTED_MODULE_0___default.a.ekmap.BasemapArcgisLayer = BasemapArcgisLayer;\n\n//# sourceURL=webpack:///./src/leaflet/layer/BasemapArcgisLayer.js?")},"./src/leaflet/layer/TileLayer.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TileLayer", function() { return TileLayer; });\n/* harmony import */ var _core_Util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Util */ "./src/leaflet/core/Util.js");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! leaflet */ "leaflet");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_1__);\n\r\n\r\n\r\n/**\r\n * @class L.ekmap.TileLayer\r\n * @classdesc The TileLayer class.\r\n * @category  Layer\r\n * @param {Object} options Construction parameters.\r\n * @param {string} options.url Required: URL of the {@link https://developers.arcgis.com/rest/services-reference/layer-feature-service-.htm|Map Service} with a tile cache.\r\n * @param {string} options.token Will use this token to authenticate all calls to the service.\r\n * @param {string} options.id Id of layer and source.\r\n * @param {string} options.name Name of layer.\r\n * @param {string} options.visibility=visible show or hide layer.\r\n * \r\n */\r\nclass TileLayer {\r\n\r\n    constructor(options) {\r\n        this.options = options ? options : {};\r\n\r\n        if (options) {\r\n            options = _core_Util__WEBPACK_IMPORTED_MODULE_0__["Util"].setOptions(this, options);\r\n            // set the urls\r\n            if (options.url) {\r\n                options = _core_Util__WEBPACK_IMPORTED_MODULE_0__["Util"].getUrlParams(options);\r\n                this.tileUrl = (options.proxy ? options.proxy + \'?\' : \'\') + options.url + \'tile/{z}/{y}/{x}\' + (options.requestParams && Object.keys(options.requestParams).length > 0 ? _core_Util__WEBPACK_IMPORTED_MODULE_0__["Util"].getParamString(options.requestParams) : \'\');\r\n                if (options.token) {\r\n                    this.tileUrl += (\'?token=\' + options.token);\r\n                }\r\n                this.tileLayer = new leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.tileLayer(this.tileUrl, )\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @function L.ekmap.TileLayer.prototype.addTo\r\n     * @description Adds the layer to the given map or layer group.\r\n     * @param {L.Map} map - Adds the layer to the given map or layer group.\r\n     * @returns this\r\n     */\r\n    addTo(map) {\r\n        return;\r\n    }\r\n}\r\n\r\nleaflet__WEBPACK_IMPORTED_MODULE_1___default.a.ekmap.TileLayer = TileLayer;\n\n//# sourceURL=webpack:///./src/leaflet/layer/TileLayer.js?')},"./src/leaflet/layer/TiledMapLayer.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TiledMapLayer", function() { return TiledMapLayer; });\n/* harmony import */ var _core_Util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Util */ "./src/leaflet/core/Util.js");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! leaflet */ "leaflet");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_1__);\n\r\n\r\n\r\n/**\r\n * @class L.ekmap.TiledMapLayer\r\n * @classdesc The TiledMapLayer class.\r\n * @category  Layer\r\n * @param {Object} options Construction parameters.\r\n * @param {string} options.url Required: URL of the {@link https://developers.arcgis.com/rest/services-reference/layer-feature-service-.htm|Map Service} with a tile cache.\r\n * @param {string} options.token Will use this token to authenticate all calls to the service.\r\n * @param {string} options.attribution Contains an attribution to be displayed when the map is shown to a user.\r\n * @param {string} options.id Id of layer and source.\r\n * @extends {L.TileLayer}\r\n */\r\nclass TiledMapLayer extends leaflet__WEBPACK_IMPORTED_MODULE_1__["TileLayer"] {\r\n\r\n    constructor(options) {\r\n        super();\r\n        this.options = options ? options : {};\r\n        if (options) {\r\n            options = _core_Util__WEBPACK_IMPORTED_MODULE_0__["Util"].setOptions(this, options);\r\n            // set the urls\r\n            if (options.url) {\r\n                options = _core_Util__WEBPACK_IMPORTED_MODULE_0__["Util"].getUrlParams(options);\r\n                this.tileUrl = (options.proxy ? options.proxy + \'?\' : \'\') + options.url + \'tile/{z}/{y}/{x}\' + (options.requestParams && Object.keys(options.requestParams).length > 0 ? _core_Util__WEBPACK_IMPORTED_MODULE_0__["Util"].getParamString(options.requestParams) : \'\');\r\n                this.service = new leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.ekmap.MapService(options);\r\n            }\r\n            if (options.urls)\r\n                this.tileUrls = options.urls\r\n            if (this.options.token) {\r\n                this.tileUrl += (\'?token=\' + this.options.token);\r\n            }\r\n            this.tileLayer = new leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.tileLayer(this.tileUrl, this.options);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @function L.ekmap.TiledMapLayer.prototype.addTo\r\n     * @description Adds the layer to the given map or layer group.\r\n     * @param {L.Map} map - Adds the layer to the given map or layer group.\r\n     * @returns this\r\n     */\r\n    addTo(map) {\r\n        this.tileLayer.addTo(map);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @function L.ekmap.TiledMapLayer.prototype.identity\r\n     * @description Returns a new L.ekmap.IdentifyFeatures object that can be used to identify features on this layer. Your callback function will be passed a GeoJSON FeatureCollection with the results or an error.\r\n     * @returns this\r\n     */\r\n    identify() {\r\n        return this.service.identify();\r\n    }\r\n\r\n    /**\r\n     * @function L.ekmap.TiledMapLayer.prototype.find\r\n     * @description Adds the layer to the given map or layer group.\r\n     * @param {Object} params - Adds the layer to the given map or layer group.\r\n     * @param {RequestCallback} callback \r\n     */\r\n    find(params, callback, context) {\r\n        return this.service.find(params, callback, context);\r\n    }\r\n\r\n    /**\r\n     * @function L.ekmap.TiledMapLayer.prototype.legend\r\n     * @description legend of Tiled Map Layer.\r\n     * @param {RequestCallback} callback\r\n     *\r\n     */\r\n    legend(callback, context) {\r\n        return this.service.legend(callback, context);\r\n    }\r\n}\r\n\r\nleaflet__WEBPACK_IMPORTED_MODULE_1___default.a.ekmap.TiledMapLayer = TiledMapLayer;\n\n//# sourceURL=webpack:///./src/leaflet/layer/TiledMapLayer.js?')},"./src/leaflet/layer/TiledOSMapLayer.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TiledOSMapLayer", function() { return TiledOSMapLayer; });\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet */ "leaflet");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);\n\r\n\r\n\r\n/**\r\n * @class L.ekmap.TiledOSMapLayer\r\n * @classdesc The TiledOSMapLayer class use url of {@link https://www.openstreetmap.org|openstreetmap}.\r\n * @category Layer\r\n * @param {Object} options - Control options.\r\n * \r\n * @extends {L.TileLayer}\r\n * @example\r\n * var map = new L.Map({\r\n *     container: \'divMapId\',\r\n *     center: [103.9, 22.2],\r\n *     zoom: 6\r\n * });\r\n * var OSMap = new L.ekmap.TiledOSMapLayer({\r\n *      token: {YOUR_API_KEY}\r\n * })\r\n *   .addTo(map);\r\n */\r\nclass TiledOSMapLayer extends leaflet__WEBPACK_IMPORTED_MODULE_0__["TileLayer"] {\r\n\r\n    constructor(options) {\r\n        super();\r\n        this.options = options ? options : {};\r\n        this.url = "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"\r\n        this.options[\'attribution\'] = "<a href=\'https://www.openstreetmap.org/\' target=\'_blank\' style=\'color: blue\'>© OpenStreetMap </a>" + "contributors";\r\n        this.TileLayer = new leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.tileLayer(this.url, this.options)\r\n    }\r\n\r\n    /**\r\n     * @function L.ekmap.TiledOSMapLayer.prototype.addTo\r\n     * @description Adds the layer to the given map or layer group.\r\n     * @param {L.Map} map - Adds the layer to the given map or layer group.\r\n     * @returns this\r\n     */\r\n    addTo(map) {\r\n        return this.TileLayer.addTo(map);\r\n    }\r\n}\r\n\r\nleaflet__WEBPACK_IMPORTED_MODULE_0___default.a.ekmap.TiledOSMapLayer = TiledOSMapLayer;\n\n//# sourceURL=webpack:///./src/leaflet/layer/TiledOSMapLayer.js?')},"./src/leaflet/layer/index.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _TiledMapLayer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TiledMapLayer */ "./src/leaflet/layer/TiledMapLayer.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TiledMapLayer", function() { return _TiledMapLayer__WEBPACK_IMPORTED_MODULE_0__["TiledMapLayer"]; });\n\n/* harmony import */ var _TileLayer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TileLayer */ "./src/leaflet/layer/TileLayer.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TileLayer", function() { return _TileLayer__WEBPACK_IMPORTED_MODULE_1__["TileLayer"]; });\n\n/* harmony import */ var _TiledOSMapLayer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TiledOSMapLayer */ "./src/leaflet/layer/TiledOSMapLayer.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TiledOSMapLayer", function() { return _TiledOSMapLayer__WEBPACK_IMPORTED_MODULE_2__["TiledOSMapLayer"]; });\n\n/* harmony import */ var _BasemapArcgisLayer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BasemapArcgisLayer */ "./src/leaflet/layer/BasemapArcgisLayer.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BasemapArcgisLayer", function() { return _BasemapArcgisLayer__WEBPACK_IMPORTED_MODULE_3__["BasemapArcgisLayer"]; });\n\n\r\n\r\n\r\n\n\n//# sourceURL=webpack:///./src/leaflet/layer/index.js?')},"./src/leaflet/services/FeatureService.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FeatureService\", function() { return FeatureService; });\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet */ \"leaflet\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Base */ \"./src/leaflet/core/Base.js\");\n/* harmony import */ var _ServiceBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ServiceBase */ \"./src/leaflet/services/ServiceBase.js\");\n/* harmony import */ var _core_Util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Util */ \"./src/leaflet/core/Util.js\");\n/* harmony import */ var _core_Parse__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/Parse */ \"./src/leaflet/core/Parse.js\");\n/* harmony import */ var _turf_turf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @turf/turf */ \"@turf/turf\");\n/* harmony import */ var _turf_turf__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_turf_turf__WEBPACK_IMPORTED_MODULE_5__);\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @class L.ekmap.FeatureService\r\n * @category  BaseType Service\r\n * @classdesc FeatureService.\r\n * @example\r\n * var featureService = new L.ekmap.FeatureService({\r\n *      url : //The URL to the Feature Service\r\n * });\r\n * featureService.query(params,function(result){\r\n *     //doSomething\r\n * })\r\n * @extends {L.ekmap.ServiceBase}\r\n * @param {object} options Construction parameters.\r\n * @param {string} options.url  (Required) The URL to the Feature Service.\r\n * @param {string} options.token - Will use this token to authenticate all calls to the service.\r\n */\r\nclass FeatureService extends _ServiceBase__WEBPACK_IMPORTED_MODULE_2__[\"ServiceBase\"] {\r\n    constructor(options) {\r\n        super(options);\r\n        if (options.url) {\r\n            this.options = _core_Util__WEBPACK_IMPORTED_MODULE_3__[\"Util\"].getUrlParams(options);\r\n        }\r\n    }\r\n\r\n    nearby(lngLat, callback, context) {\r\n        var params = {};\r\n        params.geometry = [lngLat.lng, lngLat.lat];\r\n        params.geometryType = 'esriGeometryPoint';\r\n        params.spatialRel = 'esriSpatialRelIntersects';\r\n        params.units = 'esriSRUnit_Kilometer';\r\n        params.distance = 5;\r\n        params.inSr = 4326;\r\n        params.returnIdsOnly = true;\r\n        params.f = 'json';\r\n        var service = new FeatureService(this.options);\r\n        return service.request('query', params, function(error, response) {\r\n            callback.call(context, error, response, response);\r\n        }, this);\r\n    }\r\n\r\n    /**\r\n     * @function L.ekmap.FeatureService.prototype.run\r\n     * @description  Executes the identify request with the current parameters, identified features will be passed to callback as a GeoJSON FeatureCollection. Accepts an optional function context.\r\n     * @returns {this}\r\n     */\r\n    run(callback, context) {\r\n        this._cleanParams();\r\n        var service = new FeatureService(this.options);\r\n        // services hosted on ArcGIS Online and ArcGIS Server 10.3.1+ support requesting geojson directly\r\n        if (this.options.isModern || isArcgisOnline(this.options.url)) {\r\n            this.params.f = 'geojson';\r\n\r\n            return service.request('query', params, function(error, response) {\r\n                this._trapSQLerrors(error);\r\n                callback.call(context, error, response, response);\r\n            }, this);\r\n\r\n            // otherwise convert it in the callback then pass it on\r\n        } else {\r\n            return service.request('query', params, function(error, response) {\r\n                this._trapSQLerrors(error);\r\n                callback.call(context, error, (response && responseToFeatureCollection(response)), response);\r\n            }, this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @function L.ekmap.FeatureService.prototype.addFeature\r\n     * @description Adds a new feature to the feature layer. this also adds the feature to the map if creation is successful.\r\n     * @param {GeoJSONObject} params GeoJSON of feature add (To change point color, set 'color' for options GeoJSON, the default is light blue ('#3FB1CE')).\r\n     * @param {Function} callback\r\n     * @param {Object} context\r\n     * @returns {this}\r\n     */\r\n    addFeature(params, callback, context) {\r\n        this.addFeatures(params, callback, context);\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @function L.ekmap.FeatureService.prototype.addFeatures\r\n     * @description Adds a new feature to the feature layer. this also adds the feature to the map if creation is successful.\r\n     * @param {GeoJSONObject} params GeoJSON of feature add (To change point color, set 'color' for options GeoJSON, the default is light blue ('#3FB1CE')).\r\n     * @param {Function} callback\r\n     * @param {Object} context\r\n     * @returns {this}\r\n     */\r\n    addFeatures(params, callback, context) {\r\n        var fea = _core_Parse__WEBPACK_IMPORTED_MODULE_4__[\"Parse\"].geojsonToArcGIS(params);\r\n        var data = [];\r\n        data.push(fea)\r\n        var dataPost = JSON.stringify(data)\r\n        var service = new FeatureService(this.options);\r\n        return service.post('addFeatures', dataPost, function(error, response) {\r\n            var result = (response && response.addResults) ? response.addResults.length > 1 ? response.addResults : response.addResults[0] : undefined;\r\n            callback.call(context, error || response.addResults[0].error, result);\r\n        }, this);\r\n    }\r\n\r\n    /**\r\n     * @function L.ekmap.FeatureService.prototype.updateFeature\r\n     * @description Update the provided feature on the Feature Service This also updates the feature on the map. To update the point location on the map. Please use function {@link L.ekmap.FeatureService.html#refresh|refresh()} then update.\r\n     * @param {GeoJSONObject} params Infomation feature.\r\n     * @param {Function} callback The callback of result data returned by the server side.\r\n     * @param {Object} context\r\n     * @returns {this}\r\n     */\r\n    updateFeature(params, callback, context) {\r\n        this.updateFeatures(params, callback, context);\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @function L.ekmap.FeatureService.prototype.updateFeatures\r\n     * @description Update the provided feature on the Feature Layer. This also updates the feature on the map.\r\n     * @param {GeoJSONObject} params - Infomation feature.\r\n     */\r\n    updateFeatures(params, callback, context) {\r\n        var fea = _core_Parse__WEBPACK_IMPORTED_MODULE_4__[\"Parse\"].geojsonToArcGIS(params);\r\n        var data = [];\r\n        data.push(fea)\r\n        var dataPost = JSON.stringify(data)\r\n        var service = new FeatureService(this.options);\r\n        return service.post('updateFeatures', dataPost, function(error, response) {\r\n            var result = (response && response.updateResults) ? response.updateResults.length > 1 ? response.updateResults : response.updateResults[0] : undefined;\r\n            callback.call(context, error || response.updateResults[0].error, result);\r\n        }, this);\r\n    }\r\n\r\n    /**\r\n     * @function L.ekmap.FeatureService.prototype.deleteFeature\r\n     * @description Remove the feature with the provided id from the feature layer. This will also remove the feature from the map if it exists. Please use function {@link L.ekmap.FeatureService.html#refresh|refresh()} then delete.\r\n     * @param {Interger} id Id of feature.\r\n     * @param {Function} callback The callback of result data returned by the server side.\r\n     * @param {Object} context\r\n     * @returns {this}\r\n     */\r\n    deleteFeature(id, callback, context) {\r\n        this.deleteFeatures(id, callback, context);\r\n    }\r\n\r\n    /**\r\n     * @function L.ekmap.FeatureService.prototype.deleteFeatures\r\n     * @description Removes an array of features with the provided ids from the feature layer. This will also remove the features from the map if they exist.\r\n     * @param {Integers} ids List id of features.\r\n     * @param {Function} callback The callback of result data returned by the server side.\r\n     * @param {Object} context\r\n     * @returns {this}\r\n     */\r\n    deleteFeatures(ids, callback, context) {\r\n        var service = new FeatureService(this.options);\r\n        return service.post('deleteFeatures', ids, function(error, response) {\r\n            var result = (response && response.deleteResults) ? response.deleteResults.length > 1 ? response.deleteResults : response.deleteResults[0] : undefined;\r\n            callback.call(context, error || response.deleteResults[0].error, result);\r\n        }, this);\r\n    }\r\n\r\n    /**\r\n     * @function L.ekmap.FeatureService.prototype.query\r\n     * @description Query data\r\n     * @param {Object} params - Adds the layer to the given map or layer group.\r\n     * @param {RequestCallback} callback\r\n     */\r\n    query(params, callback, context) {\r\n        var param = {};\r\n        if (params.where)\r\n            param.where = params.where;\r\n        if (params.orderByFields)\r\n            param.orderByFields = params.orderByFields;\r\n        if (params.layerDefs) {\r\n            param.f = 'json';\r\n            param.layerDefs = params.layerDefs\r\n        }\r\n        if (params.geometry) {\r\n            var geom = params.geometry;\r\n            if (params.geometry.type == 'Point') {\r\n                param.geometryType = 'esriGeometryPoint'\r\n                param.geometry = {\r\n                    \"x\": geom.coordinates[0],\r\n                    \"y\": geom.coordinates[1],\r\n                    \"spatialReference\": { \"wkid\": 4326 }\r\n                }\r\n            }\r\n            if (params.geometry.type == 'Polygon') {\r\n                param.geometryType = 'esriGeometryPolygon';\r\n                param.geometry = {\r\n                    \"rings\": geom.coordinates,\r\n                    \"spatialReference\": { \"wkid\": 4326 }\r\n                }\r\n            }\r\n            if (params.geometry.type == 'LineString')\r\n                param.geometryType = 'esriGeometryPolyline'\r\n        }\r\n        if (params.objectIds)\r\n            param.objectIds = params.objectIds\r\n\r\n        if (!params.layerDefs) {\r\n            param.outFields = '*';\r\n            param.returnGeometry = true;\r\n            param.f = 'geojson';\r\n        }\r\n        var service = new FeatureService(this.options);\r\n        return service.request('query', param, function(error, response) {\r\n            if (param.layerDefs)\r\n                var result = (response && response.layers) ? response.layers : undefined;\r\n            else\r\n                var result = (response && response.features) ? response.features : undefined;\r\n            callback.call(context, error, result);\r\n        }, this);\r\n    }\r\n\r\n    /**\r\n     * @function L.ekmap.FeatureService.prototype.queryByBound\r\n     * @description  is an abstraction for the find API included in Map Services. It provides a chainable API for building request parameters and executing find tasks.。\r\n     * @param {L.LngLatBounds} lngLatBounds\r\n     * @param {RequestCallback} callback\r\n     */\r\n    queryByBound(lngLatBounds, callback, context) {\r\n        var param = {};\r\n        var data = _core_Util__WEBPACK_IMPORTED_MODULE_3__[\"Util\"]._setGeometry(lngLatBounds);\r\n        param.f = 'geojson';\r\n        param.outFields = '*';\r\n        param.geometryType = data.geometryType;\r\n        param.geometry = data.geometry;\r\n        var me = this;\r\n        var service = new FeatureService(this.options);\r\n        return service.request('query', param, function(error, response) {\r\n            var result = undefined;\r\n            if (response && response.features)\r\n                result = response.features;\r\n            if (response && response.results)\r\n                result = response.results;\r\n            callback.call(context, error, result);\r\n        }, this);\r\n    }\r\n\r\n    /**\r\n     * @function L.ekmap.FeatureService.prototype.queryByGeometry\r\n     * @description  is an abstraction for the find API included in Map Services. It provides a chainable API for building request parameters and executing find tasks.。\r\n     * @param {Object} geometry The geometry to apply as the spatial filter. The structure of the geometry is the same as the structure of the JSON geometry objects returned by the ArcGIS REST API. In addition to the JSON structures, for envelopes and points, you can specify the geometry with a simpler comma-separated syntax.\r\n     * @param {RequestCallback} callback\r\n     */\r\n    queryByGeometry(params, callback, context) {\r\n        var param = {};\r\n        var me = this;\r\n        param.f = 'geojson'; //me.type != undefined ? me.type : 'json'; \r\n        param.outFields = '*';\r\n        if (params) {\r\n            var geom = params;\r\n            if (params.type == 'Point') {\r\n                param.geometryType = 'esriGeometryPoint'\r\n                param.geometry = {\r\n                    \"x\": geom.coordinates[0],\r\n                    \"y\": geom.coordinates[1],\r\n                    \"spatialReference\": { \"wkid\": 4326 }\r\n                }\r\n            }\r\n            if (params.type == 'Polygon') {\r\n                param.geometryType = 'esriGeometryPolygon';\r\n                var arr = geom.coordinates[0];\r\n                arr.forEach(element => {\r\n                    element[0] = Number(element[0].toFixed(6))\r\n                    element[1] = Number(element[1].toFixed(6))\r\n                });\r\n                param.geometry = {\r\n                    \"rings\": geom.coordinates,\r\n                    \"spatialReference\": { \"wkid\": 4326 }\r\n                }\r\n            }\r\n            if (params.type == 'LineString')\r\n                param.geometryType = 'esriGeometryPolyline'\r\n        }\r\n        var service = new FeatureService(this.options);\r\n        return service.request('query', param, function(error, response) {\r\n            var result = undefined;\r\n            if (response && response.features)\r\n                result = response.features;\r\n            if (response && response.results)\r\n                result = response.results;\r\n            callback.call(context, error, result);\r\n        }, this);\r\n    }\r\n\r\n    /**\r\n     * @function L.ekmap.FeatureService.prototype.applyEdits\r\n     * @description This operation adds, updates, and deletes features to the associated feature layer.\r\n     * @param {Object} params Options.\r\n     * @param {GeoJSONObject} params.adds GeoJSON of feature add.\r\n     * @param {GeoJSONObject} params.updates GeoJSON of feature update.\r\n     * @param {Interger} params.deletes Id of feature delete.\r\n     * @param {RequestCallback} callback\r\n     */\r\n    applyEdits(params, callback, context) {\r\n        var param = {}\r\n        if (params.adds) {\r\n            var dataAdd = _core_Parse__WEBPACK_IMPORTED_MODULE_4__[\"Parse\"].geojsonToArcGIS(params.adds);\r\n            var arr1 = [];\r\n            arr1.push(dataAdd);\r\n            param.adds = JSON.stringify(arr1)\r\n        } else\r\n            param.adds = false;\r\n        if (params.updates) {\r\n            var dataUpdate = _core_Parse__WEBPACK_IMPORTED_MODULE_4__[\"Parse\"].geojsonToArcGIS(params.updates);\r\n            var arr2 = [];\r\n            arr2.push(dataUpdate);\r\n            param.updates = JSON.stringify(arr2)\r\n        } else\r\n            param.updates = false;\r\n        if (params.deletes)\r\n            param.deletes = params.deletes;\r\n        else\r\n            param.deletes = false;\r\n        var service = new FeatureService(this.options);\r\n        return service.post('applyEdits', param, function(error, response) {\r\n            callback.call(context, error, response, response);\r\n        }, this);\r\n    }\r\n\r\n    /**\r\n     * @function L.ekmap.FeatureService.prototype.refresh\r\n     * @description Redraws all features from the feature layer that exist on the map.\r\n     */\r\n    refresh() {\r\n        var me = this;\r\n        var data = {};\r\n        var params = {\r\n            where: '1=1'\r\n        };\r\n\r\n        this.query(params, function(result) {\r\n            data = {\r\n                'type': 'FeatureCollection',\r\n                'features': result\r\n            };\r\n            if (me.map.getLayer('point')) {\r\n                me.map.getSource('point').setData(data);\r\n            }\r\n            if (me.map.getLayer('line')) {\r\n                me.map.getSource('line').setData(data);\r\n            }\r\n            if (me.map.getLayer('area')) {\r\n                me.map.getSource('area').setData(data);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @function L.ekmap.FeatureService.prototype.on\r\n     * @description On map.\r\n     * @param {L.Map} map The map is defined.\r\n     * @returns {this}\r\n     */\r\n    on(map) {\r\n        this.map = map\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @function L.ekmap.FeatureService.prototype.param\r\n     * @description param.\r\n     * @param {string} type type.\r\n     * @returns {this}\r\n     */\r\n    f(type) {\r\n            this.type = type;\r\n            return this;\r\n        }\r\n        /**\r\n         * @function L.ekmap.FeatureService.prototype.removeFeature\r\n         * @description Remove feature selected.\r\n         */\r\n    removeFeature() {\r\n        var layers = this.map.getStyle().layers;\r\n        layers.forEach(layer => {\r\n            if (layer.id.indexOf('queryEK-') != -1) {\r\n                this.map.removeLayer(layer.id)\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nleaflet__WEBPACK_IMPORTED_MODULE_0___default.a.ekmap.FeatureService = FeatureService;\n\n//# sourceURL=webpack:///./src/leaflet/services/FeatureService.js?")},"./src/leaflet/services/IdentifyFeatures.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IdentifyFeatures\", function() { return IdentifyFeatures; });\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet */ \"leaflet\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Base */ \"./src/leaflet/core/Base.js\");\n/* harmony import */ var _ServiceBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ServiceBase */ \"./src/leaflet/services/ServiceBase.js\");\n/* harmony import */ var _core_Util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Util */ \"./src/leaflet/core/Util.js\");\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @class L.ekmap.IdentifyFeatures\r\n * @category  BaseType Service\r\n * @classdesc  L.ekmap.IdentifyFeatures is an abstraction for the Identify API found in Map Services. It provides a chainable API for building request parameters and executing the request.\r\n * @extends {L.ekmap.ServiceBase}\r\n * @param {object} options Construction parameters.\r\n * @param {string} options.url URL of the ArcGIS service you would like to consume.\r\n * @param {string} options.token - Will use this token to authenticate all calls to the service.\r\n * @example\r\n * var map = new L.Map({\r\n *      container: 'divMapId',\r\n *      center: [103.9, 22.2],\r\n *      zoom: 6\r\n * })\r\n * var identify = new L.ekmap.IdentifyFeatures({\r\n *      url: 'https://viegisserver.ekgis.vn/gserver/rest/services/35/MapServer'\r\n * })\r\n *   .on(map)\r\n *   .at([])\r\n *   .run(function (obj) {\r\n *      console.log();\r\n *   })\r\n *     //doSomething\r\n * })\r\n */\r\nclass IdentifyFeatures extends _ServiceBase__WEBPACK_IMPORTED_MODULE_2__[\"ServiceBase\"] {\r\n\r\n    constructor(options) {\r\n        super(options);\r\n        if (options.url)\r\n            this.options = _core_Util__WEBPACK_IMPORTED_MODULE_3__[\"Util\"].getUrlParams(options);\r\n        this.paramsIdentify = {\r\n            geometry: '',\r\n            sr: 4326,\r\n            layers: 'all',\r\n            tolerance: 6,\r\n            returnGeometry: true,\r\n            f: 'json'\r\n        };\r\n    }\r\n\r\n    /**\r\n     * @function L.ekmap.IdentifyFeatures.prototype.on\r\n     * @description  The map to identify features on.\r\n     * @param {L.Map} map The map is defined.\r\n     * @returns {this}\r\n     */\r\n    on(map) {\r\n        var bounds = new leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.LngLatBounds(map.getBounds()._sw, map.getBounds()._ne);\r\n        var extent = {\r\n            'xmin': bounds.getSouthWest().lng,\r\n            'ymin': bounds.getSouthWest().lat,\r\n            'xmax': bounds.getNorthEast().lng,\r\n            'ymax': bounds.getNorthEast().lat,\r\n            'spatialReference': {\r\n                'wkid': 4326\r\n            }\r\n        };\r\n        var size = map.getContainer()\r\n        this.paramsIdentify.imageDisplay = [size.clientWidth, size.clientHeight, 96];\r\n        this.paramsIdentify.mapExtent = [extent.xmin, extent.ymin, extent.xmax, extent.ymax];\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @function L.ekmap.IdentifyFeatures.prototype.at\r\n     * @description  Identifies features at a given {@link https://docs.mapbox.com/mapbox-gl-js/api/geography/#lnglatbounds|L.LatLngBounds} or a valid GeoJSON object literal.\r\n     * @returns {this}\r\n     */\r\n    at(geometry) {\r\n        if (geometry.length === 2)\r\n            geometry = new leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.LngLat(geometry);\r\n        this._setGeometryParams(geometry);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @function L.ekmap.IdentifyFeatures.prototype.run\r\n     * @description  Executes the identify request with the current parameters, identified features will be passed to callback as a GeoJSON FeatureCollection. Accepts an optional function context.\r\n     * @returns {this}\r\n     */\r\n    run(callback, context) {\r\n        var service = new IdentifyFeatures(this.options);\r\n        return service.request('identify', this.paramsIdentify, function(error, response) {\r\n            // immediately invoke with an error\r\n\r\n            callback.call(context, error, response.results);\r\n        }, this);\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @function L.ekmap.IdentifyFeatures.prototype._setGeometryParams\r\n     * @description Set geometry params.\r\n     */\r\n    _setGeometryParams(geometry) {\r\n        var converted = _core_Util__WEBPACK_IMPORTED_MODULE_3__[\"Util\"]._setGeometry(geometry);\r\n        this.paramsIdentify.geometry = converted.geometry;\r\n        this.paramsIdentify.geometryType = converted.geometryType;\r\n    }\r\n}\r\n\r\nleaflet__WEBPACK_IMPORTED_MODULE_0___default.a.ekmap.IdentifyFeatures = IdentifyFeatures;\n\n//# sourceURL=webpack:///./src/leaflet/services/IdentifyFeatures.js?")},"./src/leaflet/services/MapService.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MapService\", function() { return MapService; });\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet */ \"leaflet\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Base */ \"./src/leaflet/core/Base.js\");\n/* harmony import */ var _ServiceBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ServiceBase */ \"./src/leaflet/services/ServiceBase.js\");\n/* harmony import */ var _core_Util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Util */ \"./src/leaflet/core/Util.js\");\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @class L.ekmap.MapService\r\n * @category  BaseType Service\r\n * @classdesc The MapService class.\r\n * @extends {L.ekmap.ServiceBase}\r\n * @param {object} options Construction parameters.\r\n * @param {string} options.url (Required) The URL to the MapService.\r\n * @param {string} options.token Will use this token to authenticate all calls to the service.\r\n * @example\r\n * var mapService = new L.ekmap.MapService({\r\n *      url: //The URL to the MapService\r\n * });\r\n * mapService.identify(function(result){\r\n *     //doSomething\r\n * })\r\n */\r\nclass MapService extends _ServiceBase__WEBPACK_IMPORTED_MODULE_2__[\"ServiceBase\"] {\r\n\r\n    constructor(options) {\r\n        super(options);\r\n        this.options = _core_Util__WEBPACK_IMPORTED_MODULE_3__[\"Util\"].getUrlParams(options);\r\n        this.paramsIdentify = {\r\n            geometry: '',\r\n            sr: 4326,\r\n            layers: 'all',\r\n            tolerance: 3,\r\n            returnGeometry: true\r\n        };\r\n    }\r\n\r\n    /**\r\n     * @function L.ekmap.MapService.prototype.identify\r\n     * @description Returns a new L.ekmap.IdentifyFeatures object that can be used to identify features contained within this service.\r\n     */\r\n    identify() {\r\n        return new leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.ekmap.IdentifyFeatures(this.options);\r\n    }\r\n\r\n    /**\r\n     * @function L.ekmap.MapService.prototype.find\r\n     * @description  Is an abstraction for the find API included in Map Services. It provides a chainable API for building request parameters and executing find tasks.\r\n     * @param {Object} params\r\n     * @param {string} params.f=json The response format. The default response format is html.\r\n     * @param {string} params.searchText (Required) The search string. This is the text that is searched across the layers and fields the user specifies.\r\n     * @param {RequestCallback} callback The callback of result data returned by the server side.\r\n     */\r\n    find(params, callback, context) {\r\n        var me = this;\r\n        this.legend(function(obj) {\r\n            var layers = [];\r\n            var list = obj.layers;\r\n            list.forEach(layer => {\r\n                layers.push(layer.layerId);\r\n            })\r\n            var param = {};\r\n            param.searchText = params.searchText;\r\n            param.layers = layers.toString();\r\n            param.f = 'json';\r\n            var service = new MapService(me.options);\r\n            return service.request('find', param, function(error, response) {\r\n                callback.call(context, response.results);\r\n            }, me);\r\n        })\r\n\r\n    }\r\n\r\n    /**\r\n     * @function L.ekmap.MapService.prototype.query\r\n     * @description  Is an abstraction for the find API included in Map Services. It provides a chainable API for building request parameters and executing find tasks.。\r\n     * @param {Object} params\r\n     * @param {string} params.f=json The response format. The default response format is json.\r\n     * @param {string} params.where A WHERE clause for the query filter. Any legal SQL WHERE clause operating on the fields in the layer is allowed.\r\n     * @param {string} params.text A literal search text. If the layer has a display field associated with it, the server searches for this text in this field. This parameter is shorthand for a WHERE clause of where <displayField> like '%<text>%'. The text is case sensitive. This parameter is ignored if the WHERE parameter is specified.\r\n     * @param {RequestCallback} callback The callback of result data returned by the server side.\r\n     */\r\n    query(params, callback, context) {\r\n        var param = {};\r\n        param.where = params.where;\r\n        param.text = params.text;\r\n        param.objectIds = params.objectId;\r\n        param.f = 'json';\r\n        var service = new MapService(this.options);\r\n        return service.request('query', param, function(error, response) {\r\n            var result = (response && response.features) ? response.features : undefined;\r\n            callback.call(context, error, result);\r\n        }, this);\r\n    }\r\n\r\n    /**\r\n     * @function L.ekmap.MapService.prototype.getLayers\r\n     * @description  Get list layer on map. \r\n     * @param {RequestCallback} callback The callback of result data returned by the server side.\r\n     */\r\n    getLayers(callback, context) {\r\n        var params = {};\r\n        params.f = 'json';\r\n        var service = new MapService(this.options);\r\n        return service.request('layers', params, function(error, response) {\r\n            callback.call(context, response);\r\n        }, this);\r\n    }\r\n\r\n    /**\r\n     * @function L.ekmap.MapService.prototype.legend\r\n     * @description  Get legend on map.\r\n     * @param {RequestCallback} callback The callback of result data returned by the server side.\r\n     */\r\n    legend(callback, context) {\r\n        var params = {};\r\n        params.f = 'json';\r\n        var service = new MapService(this.options);\r\n        return service.request('legend', params, function(error, response) {\r\n            console.log(response)\r\n            callback.call(context, response);\r\n        }, this);\r\n    }\r\n\r\n    /**\r\n     * @function L.ekmap.MapService.prototype.queryByBound\r\n     * @description  Is an abstraction for the query API included in Map Services. It provides a chainable API for building request parameters and executing find tasks.\r\n     * @param {L.LngLatBounds} lngLatBounds\r\n     * @param {RequestCallback} callback The callback of result data returned by the server side.\r\n     */\r\n    queryByBound(params, callback, context) {\r\n        var param = {};\r\n        var data = _core_Util__WEBPACK_IMPORTED_MODULE_3__[\"Util\"]._setGeometry(params);\r\n        param.f = 'geojson';\r\n        param.geometryType = data.geometryType;\r\n        param.geometry = data.geometry;\r\n        var me = this;\r\n        var service = new MapService(this.options);\r\n        return service.request('query', param, function(error, response) {\r\n            var result = (response && response.features) ? response.features : undefined;\r\n            callback.call(context, error, result);\r\n        }, this);\r\n    }\r\n\r\n    /**\r\n     * @function L.ekmap.MapService.prototype.queryByGeometry\r\n     * @description  Is an abstraction for the find API included in Map Services. It provides a chainable API for building request parameters and executing find tasks.。\r\n     * @param {Object} geometry The geometry to apply as the spatial filter. The structure of the geometry is the same as the structure of the JSON geometry objects returned by the ArcGIS REST API. In addition to the JSON structures, for envelopes and points, you can specify the geometry with a simpler comma-separated syntax.\r\n     * @param {RequestCallback} callback The callback of result data returned by the server side.\r\n     */\r\n    queryByGeometry(params, callback, context) {\r\n\r\n        var param = {};\r\n        param.f = 'geojson';\r\n        var data = _core_Util__WEBPACK_IMPORTED_MODULE_3__[\"Util\"]._setGeometry(params);\r\n        param.geometryType = data.geometryType;\r\n        param.geometry = data.geometry;\r\n        var me = this;\r\n        var service = new MapService(this.options);\r\n        return service.request('query', param, function(error, response) {\r\n            var result = (response && response.features) ? response.features : undefined;\r\n            callback.call(context, error, result);\r\n        }, this);\r\n    }\r\n\r\n    /**\r\n     * @function L.ekmap.MapService.prototype.on\r\n     * @description On map.\r\n     * @param {L.Map} map The map is defined.\r\n     * @returns {this}\r\n     */\r\n    on(map) {\r\n        this.map = map\r\n        return this;\r\n    }\r\n\r\n}\r\n\r\nleaflet__WEBPACK_IMPORTED_MODULE_0___default.a.ekmap.MapService = MapService;\n\n//# sourceURL=webpack:///./src/leaflet/services/MapService.js?")},"./src/leaflet/services/ServiceBase.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ServiceBase", function() { return ServiceBase; });\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet */ "leaflet");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Base */ "./src/leaflet/core/Base.js");\n/* harmony import */ var _core_Util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Util */ "./src/leaflet/core/Util.js");\n/* harmony import */ var _core_Request__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Request */ "./src/leaflet/core/Request.js");\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @class L.ekmap.ServiceBase\r\n * @category  BaseType Service\r\n * @description L.ekmap base class.\r\n * @param {Object} options The optional parameters.\r\n * @param {string} options.url (Required) The URL to the MapService.\r\n * @param {string} options.token - Will use this token to authenticate all calls to the service.\r\n * @param {string} options.tokenKey - Will use this token to authenticate all calls to the service.\r\n * @extends {L.Evented}\r\n * \r\n */\r\nclass ServiceBase extends leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.Evented {\r\n\r\n    constructor(options) {\r\n        super(options);\r\n        this.options = _core_Util__WEBPACK_IMPORTED_MODULE_2__["Util"].getUrlParams(options);\r\n        this.url = this.options.url;\r\n        /**\r\n         * @event L.ekmap.ServiceBase#initialized\r\n         * @description .\r\n         * @property {Object} this this .\r\n         */\r\n        this.fire(\'initialized\', this);\r\n    }\r\n\r\n    request(path, params, callback, context) {\r\n        return this._request(path, params, callback, context);\r\n    }\r\n\r\n    _request(path, params, callback, context) {\r\n        this.fire(\'requeststart\', {\r\n            url: this.url + path,\r\n            params: params,\r\n        }, true);\r\n        if (this.options.token) {\r\n            params.token = this.options.token;\r\n        }\r\n        if (this.options.tokenKey) {\r\n            params.tokenKey = this.options.tokenKey;\r\n        }\r\n        if (this.options.requestParams) {\r\n            _core_Util__WEBPACK_IMPORTED_MODULE_2__["Util"].extend(params, this.options.requestParams);\r\n        }\r\n        if (this._authenticating) {\r\n            return;\r\n        } else {\r\n            var url = this.url + path;\r\n            return _core_Request__WEBPACK_IMPORTED_MODULE_3__["Request"].send(url + \'?\' + _core_Util__WEBPACK_IMPORTED_MODULE_2__["Util"].serialize(params), "", {}, callback);\r\n        }\r\n    }\r\n\r\n    post(path, dataPost, callback, context) {\r\n        return this._post(path, dataPost, callback, context);\r\n    }\r\n\r\n    _post(path, dataPost, callback, context) {\r\n        this.fire(\'poststart\', {\r\n            url: this.url + path,\r\n            dataPost: dataPost,\r\n        }, true);\r\n        if (this.options.requestParams) {\r\n            _core_Util__WEBPACK_IMPORTED_MODULE_2__["Util"].extend(dataPost, this.options.requestParams);\r\n        }\r\n        var data = {};\r\n        if (this.options.token) {\r\n            data.token = this.options.token;\r\n        }\r\n        if (this._authenticating) {\r\n            this._requestQueue.push([method, path, dataPost, callback, context]);\r\n            return;\r\n        } else {\r\n            var url = this.url + path;\r\n            return _core_Request__WEBPACK_IMPORTED_MODULE_3__["Request"].post(url + \'?\' + _core_Util__WEBPACK_IMPORTED_MODULE_2__["Util"].serialize(data), dataPost, this.options, callback);\r\n        }\r\n    }\r\n\r\n    _createServiceCallback(method, path, params, callback, context) {\r\n        return _core_Util__WEBPACK_IMPORTED_MODULE_2__["Util"].bind(function(error, response) {\r\n            if (error && (error.code === 499 || error.code === 498)) {\r\n                this._authenticating = true;\r\n\r\n                this._requestQueue.push([method, path, params, callback, context]);\r\n\r\n                // fire an event for users to handle and re-authenticate\r\n                this.fire(\'authenticationrequired\', {\r\n                    authenticate: _core_Util__WEBPACK_IMPORTED_MODULE_2__["Util"].bind(this.authenticate, this)\r\n                }, true);\r\n\r\n                // if the user has access to a callback they can handle the auth error\r\n                error.authenticate = _core_Util__WEBPACK_IMPORTED_MODULE_2__["Util"].bind(this.authenticate, this);\r\n            }\r\n\r\n            callback.call(context, error, response);\r\n\r\n            if (error) {\r\n                this.fire(\'requesterror\', {\r\n                    url: this.options.url + path,\r\n                    params: params,\r\n                    message: error.message,\r\n                    code: error.code,\r\n                    method: method\r\n                }, true);\r\n            } else {\r\n                this.fire(\'requestsuccess\', {\r\n                    url: this.options.url + path,\r\n                    params: params,\r\n                    response: response,\r\n                    method: method\r\n                }, true);\r\n            }\r\n\r\n            this.fire(\'requestend\', {\r\n                url: this.options.url + path,\r\n                params: params,\r\n                method: method\r\n            }, true);\r\n        }, this);\r\n    }\r\n}\r\n\r\nleaflet__WEBPACK_IMPORTED_MODULE_0___default.a.ekmap.ServiceBase = ServiceBase;\n\n//# sourceURL=webpack:///./src/leaflet/services/ServiceBase.js?')},"./src/leaflet/services/index.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _FeatureService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FeatureService */ "./src/leaflet/services/FeatureService.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FeatureService", function() { return _FeatureService__WEBPACK_IMPORTED_MODULE_0__["FeatureService"]; });\n\n/* harmony import */ var _MapService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MapService */ "./src/leaflet/services/MapService.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MapService", function() { return _MapService__WEBPACK_IMPORTED_MODULE_1__["MapService"]; });\n\n/* harmony import */ var _ServiceBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ServiceBase */ "./src/leaflet/services/ServiceBase.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ServiceBase", function() { return _ServiceBase__WEBPACK_IMPORTED_MODULE_2__["ServiceBase"]; });\n\n/* harmony import */ var _IdentifyFeatures__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./IdentifyFeatures */ "./src/leaflet/services/IdentifyFeatures.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "IdentifyFeatures", function() { return _IdentifyFeatures__WEBPACK_IMPORTED_MODULE_3__["IdentifyFeatures"]; });\n\n\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack:///./src/leaflet/services/index.js?')},0:function(module,exports,__webpack_require__){eval('__webpack_require__(/*! D:\\Dev\\eKMap\\eKMap-Client\\src\\leaflet\\index.js */"./src/leaflet/index.js");\nmodule.exports = __webpack_require__(/*! D:\\Dev\\eKMap\\eKMap-Client\\src\\leaflet\\css\\index.js */"./src/leaflet/css/index.js");\n\n\n//# sourceURL=webpack:///multi_./src/leaflet/index.js_./src/leaflet/css/index.js?')},"@turf/turf":function(module,exports){eval("module.exports = function(){try{return turf}catch(e){return {}}}();\n\n//# sourceURL=webpack:///external_%22function()%7Btry%7Breturn_turf%7Dcatch(e)%7Breturn_%7B%7D%7D%7D()%22?")},leaflet:function(module,exports){eval("module.exports = L;\n\n//# sourceURL=webpack:///external_%22L%22?")}});